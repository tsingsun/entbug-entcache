// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/bug/ent/predicate"
	"entgo.io/bug/ent/securityjournal"
	"entgo.io/bug/ent/securityposition"
	"entgo.io/bug/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeSecurityJournal  = "SecurityJournal"
	TypeSecurityPosition = "SecurityPosition"
	TypeUser             = "User"
)

// SecurityJournalMutation represents an operation that mutates the SecurityJournal nodes in the graph.
type SecurityJournalMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	security_account_id         *int
	addsecurity_account_id      *int
	account_id                  *int
	addaccount_id               *int
	biz_no                      *string
	biz_type                    *string
	org_id                      *int
	addorg_id                   *int
	trade_code                  *string
	change_type                 *string
	record_method_id            *int
	addrecord_method_id         *int
	project_id                  *int
	addproject_id               *int
	product_id                  *int
	addproduct_id               *int
	material_id                 *int
	addmaterial_id              *int
	material_no                 *string
	material_name               *string
	multiplier                  *float64
	addmultiplier               *float64
	position_type               *int
	addposition_type            *int
	currency                    *string
	qty                         *float64
	addqty                      *float64
	price                       *float64
	addprice                    *float64
	amount                      *float64
	addamount                   *float64
	cost                        *float64
	addcost                     *float64
	total                       *float64
	addtotal                    *float64
	unit                        *string
	spec                        *string
	commission                  *float64
	addcommission               *float64
	fee                         *float64
	addfee                      *float64
	fee_other                   *float64
	addfee_other                *float64
	count                       *int
	addcount                    *int
	direction                   *int
	adddirection                *int
	tamper                      *string
	summary                     *string
	pair_subject_code           *string
	pair_security_account_id    *int
	addpair_security_account_id *int
	last_balance                *float64
	addlast_balance             *float64
	stl_time                    *time.Time
	fx_rate                     *float64
	addfx_rate                  *float64
	stl_currency                *string
	stl_amount                  *float64
	addstl_amount               *float64
	stl_margin_lv               *float64
	addstl_margin_lv            *float64
	is_settlement               *string
	actual_stl_time             *time.Time
	trans_no                    *string
	trans_time                  *time.Time
	accounting_no               *string
	accounting_time             *time.Time
	accounted_position_qty      *float64
	addaccounted_position_qty   *float64
	cd_direction                *int
	addcd_direction             *int
	apply_fields                *string
	created_at                  *time.Time
	ref_trans_no                *string
	is_day_booking              *string
	is_effect_fund              *string
	clearedFields               map[string]struct{}
	done                        bool
	oldValue                    func(context.Context) (*SecurityJournal, error)
	predicates                  []predicate.SecurityJournal
}

var _ ent.Mutation = (*SecurityJournalMutation)(nil)

// securityjournalOption allows management of the mutation configuration using functional options.
type securityjournalOption func(*SecurityJournalMutation)

// newSecurityJournalMutation creates new mutation for the SecurityJournal entity.
func newSecurityJournalMutation(c config, op Op, opts ...securityjournalOption) *SecurityJournalMutation {
	m := &SecurityJournalMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityJournal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityJournalID sets the ID field of the mutation.
func withSecurityJournalID(id int) securityjournalOption {
	return func(m *SecurityJournalMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityJournal
		)
		m.oldValue = func(ctx context.Context) (*SecurityJournal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityJournal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityJournal sets the old SecurityJournal of the mutation.
func withSecurityJournal(node *SecurityJournal) securityjournalOption {
	return func(m *SecurityJournalMutation) {
		m.oldValue = func(context.Context) (*SecurityJournal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityJournalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityJournalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SecurityJournal entities.
func (m *SecurityJournalMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecurityJournalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecurityJournalMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SecurityJournal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSecurityAccountID sets the "security_account_id" field.
func (m *SecurityJournalMutation) SetSecurityAccountID(i int) {
	m.security_account_id = &i
	m.addsecurity_account_id = nil
}

// SecurityAccountID returns the value of the "security_account_id" field in the mutation.
func (m *SecurityJournalMutation) SecurityAccountID() (r int, exists bool) {
	v := m.security_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityAccountID returns the old "security_account_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldSecurityAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityAccountID: %w", err)
	}
	return oldValue.SecurityAccountID, nil
}

// AddSecurityAccountID adds i to the "security_account_id" field.
func (m *SecurityJournalMutation) AddSecurityAccountID(i int) {
	if m.addsecurity_account_id != nil {
		*m.addsecurity_account_id += i
	} else {
		m.addsecurity_account_id = &i
	}
}

// AddedSecurityAccountID returns the value that was added to the "security_account_id" field in this mutation.
func (m *SecurityJournalMutation) AddedSecurityAccountID() (r int, exists bool) {
	v := m.addsecurity_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecurityAccountID resets all changes to the "security_account_id" field.
func (m *SecurityJournalMutation) ResetSecurityAccountID() {
	m.security_account_id = nil
	m.addsecurity_account_id = nil
}

// SetAccountID sets the "account_id" field.
func (m *SecurityJournalMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *SecurityJournalMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *SecurityJournalMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *SecurityJournalMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccountID clears the value of the "account_id" field.
func (m *SecurityJournalMutation) ClearAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
	m.clearedFields[securityjournal.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *SecurityJournalMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *SecurityJournalMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
	delete(m.clearedFields, securityjournal.FieldAccountID)
}

// SetBizNo sets the "biz_no" field.
func (m *SecurityJournalMutation) SetBizNo(s string) {
	m.biz_no = &s
}

// BizNo returns the value of the "biz_no" field in the mutation.
func (m *SecurityJournalMutation) BizNo() (r string, exists bool) {
	v := m.biz_no
	if v == nil {
		return
	}
	return *v, true
}

// OldBizNo returns the old "biz_no" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldBizNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizNo: %w", err)
	}
	return oldValue.BizNo, nil
}

// ClearBizNo clears the value of the "biz_no" field.
func (m *SecurityJournalMutation) ClearBizNo() {
	m.biz_no = nil
	m.clearedFields[securityjournal.FieldBizNo] = struct{}{}
}

// BizNoCleared returns if the "biz_no" field was cleared in this mutation.
func (m *SecurityJournalMutation) BizNoCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldBizNo]
	return ok
}

// ResetBizNo resets all changes to the "biz_no" field.
func (m *SecurityJournalMutation) ResetBizNo() {
	m.biz_no = nil
	delete(m.clearedFields, securityjournal.FieldBizNo)
}

// SetBizType sets the "biz_type" field.
func (m *SecurityJournalMutation) SetBizType(s string) {
	m.biz_type = &s
}

// BizType returns the value of the "biz_type" field in the mutation.
func (m *SecurityJournalMutation) BizType() (r string, exists bool) {
	v := m.biz_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBizType returns the old "biz_type" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldBizType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizType: %w", err)
	}
	return oldValue.BizType, nil
}

// ClearBizType clears the value of the "biz_type" field.
func (m *SecurityJournalMutation) ClearBizType() {
	m.biz_type = nil
	m.clearedFields[securityjournal.FieldBizType] = struct{}{}
}

// BizTypeCleared returns if the "biz_type" field was cleared in this mutation.
func (m *SecurityJournalMutation) BizTypeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldBizType]
	return ok
}

// ResetBizType resets all changes to the "biz_type" field.
func (m *SecurityJournalMutation) ResetBizType() {
	m.biz_type = nil
	delete(m.clearedFields, securityjournal.FieldBizType)
}

// SetOrgID sets the "org_id" field.
func (m *SecurityJournalMutation) SetOrgID(i int) {
	m.org_id = &i
	m.addorg_id = nil
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *SecurityJournalMutation) OrgID() (r int, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// AddOrgID adds i to the "org_id" field.
func (m *SecurityJournalMutation) AddOrgID(i int) {
	if m.addorg_id != nil {
		*m.addorg_id += i
	} else {
		m.addorg_id = &i
	}
}

// AddedOrgID returns the value that was added to the "org_id" field in this mutation.
func (m *SecurityJournalMutation) AddedOrgID() (r int, exists bool) {
	v := m.addorg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *SecurityJournalMutation) ResetOrgID() {
	m.org_id = nil
	m.addorg_id = nil
}

// SetTradeCode sets the "trade_code" field.
func (m *SecurityJournalMutation) SetTradeCode(s string) {
	m.trade_code = &s
}

// TradeCode returns the value of the "trade_code" field in the mutation.
func (m *SecurityJournalMutation) TradeCode() (r string, exists bool) {
	v := m.trade_code
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeCode returns the old "trade_code" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldTradeCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeCode: %w", err)
	}
	return oldValue.TradeCode, nil
}

// ClearTradeCode clears the value of the "trade_code" field.
func (m *SecurityJournalMutation) ClearTradeCode() {
	m.trade_code = nil
	m.clearedFields[securityjournal.FieldTradeCode] = struct{}{}
}

// TradeCodeCleared returns if the "trade_code" field was cleared in this mutation.
func (m *SecurityJournalMutation) TradeCodeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldTradeCode]
	return ok
}

// ResetTradeCode resets all changes to the "trade_code" field.
func (m *SecurityJournalMutation) ResetTradeCode() {
	m.trade_code = nil
	delete(m.clearedFields, securityjournal.FieldTradeCode)
}

// SetChangeType sets the "change_type" field.
func (m *SecurityJournalMutation) SetChangeType(s string) {
	m.change_type = &s
}

// ChangeType returns the value of the "change_type" field in the mutation.
func (m *SecurityJournalMutation) ChangeType() (r string, exists bool) {
	v := m.change_type
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeType returns the old "change_type" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldChangeType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeType: %w", err)
	}
	return oldValue.ChangeType, nil
}

// ClearChangeType clears the value of the "change_type" field.
func (m *SecurityJournalMutation) ClearChangeType() {
	m.change_type = nil
	m.clearedFields[securityjournal.FieldChangeType] = struct{}{}
}

// ChangeTypeCleared returns if the "change_type" field was cleared in this mutation.
func (m *SecurityJournalMutation) ChangeTypeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldChangeType]
	return ok
}

// ResetChangeType resets all changes to the "change_type" field.
func (m *SecurityJournalMutation) ResetChangeType() {
	m.change_type = nil
	delete(m.clearedFields, securityjournal.FieldChangeType)
}

// SetRecordMethodID sets the "record_method_id" field.
func (m *SecurityJournalMutation) SetRecordMethodID(i int) {
	m.record_method_id = &i
	m.addrecord_method_id = nil
}

// RecordMethodID returns the value of the "record_method_id" field in the mutation.
func (m *SecurityJournalMutation) RecordMethodID() (r int, exists bool) {
	v := m.record_method_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRecordMethodID returns the old "record_method_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldRecordMethodID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecordMethodID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecordMethodID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecordMethodID: %w", err)
	}
	return oldValue.RecordMethodID, nil
}

// AddRecordMethodID adds i to the "record_method_id" field.
func (m *SecurityJournalMutation) AddRecordMethodID(i int) {
	if m.addrecord_method_id != nil {
		*m.addrecord_method_id += i
	} else {
		m.addrecord_method_id = &i
	}
}

// AddedRecordMethodID returns the value that was added to the "record_method_id" field in this mutation.
func (m *SecurityJournalMutation) AddedRecordMethodID() (r int, exists bool) {
	v := m.addrecord_method_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRecordMethodID clears the value of the "record_method_id" field.
func (m *SecurityJournalMutation) ClearRecordMethodID() {
	m.record_method_id = nil
	m.addrecord_method_id = nil
	m.clearedFields[securityjournal.FieldRecordMethodID] = struct{}{}
}

// RecordMethodIDCleared returns if the "record_method_id" field was cleared in this mutation.
func (m *SecurityJournalMutation) RecordMethodIDCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldRecordMethodID]
	return ok
}

// ResetRecordMethodID resets all changes to the "record_method_id" field.
func (m *SecurityJournalMutation) ResetRecordMethodID() {
	m.record_method_id = nil
	m.addrecord_method_id = nil
	delete(m.clearedFields, securityjournal.FieldRecordMethodID)
}

// SetProjectID sets the "project_id" field.
func (m *SecurityJournalMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *SecurityJournalMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *SecurityJournalMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *SecurityJournalMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProjectID clears the value of the "project_id" field.
func (m *SecurityJournalMutation) ClearProjectID() {
	m.project_id = nil
	m.addproject_id = nil
	m.clearedFields[securityjournal.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *SecurityJournalMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *SecurityJournalMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
	delete(m.clearedFields, securityjournal.FieldProjectID)
}

// SetProductID sets the "product_id" field.
func (m *SecurityJournalMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *SecurityJournalMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *SecurityJournalMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *SecurityJournalMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *SecurityJournalMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[securityjournal.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *SecurityJournalMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *SecurityJournalMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, securityjournal.FieldProductID)
}

// SetMaterialID sets the "material_id" field.
func (m *SecurityJournalMutation) SetMaterialID(i int) {
	m.material_id = &i
	m.addmaterial_id = nil
}

// MaterialID returns the value of the "material_id" field in the mutation.
func (m *SecurityJournalMutation) MaterialID() (r int, exists bool) {
	v := m.material_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialID returns the old "material_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldMaterialID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialID: %w", err)
	}
	return oldValue.MaterialID, nil
}

// AddMaterialID adds i to the "material_id" field.
func (m *SecurityJournalMutation) AddMaterialID(i int) {
	if m.addmaterial_id != nil {
		*m.addmaterial_id += i
	} else {
		m.addmaterial_id = &i
	}
}

// AddedMaterialID returns the value that was added to the "material_id" field in this mutation.
func (m *SecurityJournalMutation) AddedMaterialID() (r int, exists bool) {
	v := m.addmaterial_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaterialID clears the value of the "material_id" field.
func (m *SecurityJournalMutation) ClearMaterialID() {
	m.material_id = nil
	m.addmaterial_id = nil
	m.clearedFields[securityjournal.FieldMaterialID] = struct{}{}
}

// MaterialIDCleared returns if the "material_id" field was cleared in this mutation.
func (m *SecurityJournalMutation) MaterialIDCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldMaterialID]
	return ok
}

// ResetMaterialID resets all changes to the "material_id" field.
func (m *SecurityJournalMutation) ResetMaterialID() {
	m.material_id = nil
	m.addmaterial_id = nil
	delete(m.clearedFields, securityjournal.FieldMaterialID)
}

// SetMaterialNo sets the "material_no" field.
func (m *SecurityJournalMutation) SetMaterialNo(s string) {
	m.material_no = &s
}

// MaterialNo returns the value of the "material_no" field in the mutation.
func (m *SecurityJournalMutation) MaterialNo() (r string, exists bool) {
	v := m.material_no
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialNo returns the old "material_no" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldMaterialNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialNo: %w", err)
	}
	return oldValue.MaterialNo, nil
}

// ClearMaterialNo clears the value of the "material_no" field.
func (m *SecurityJournalMutation) ClearMaterialNo() {
	m.material_no = nil
	m.clearedFields[securityjournal.FieldMaterialNo] = struct{}{}
}

// MaterialNoCleared returns if the "material_no" field was cleared in this mutation.
func (m *SecurityJournalMutation) MaterialNoCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldMaterialNo]
	return ok
}

// ResetMaterialNo resets all changes to the "material_no" field.
func (m *SecurityJournalMutation) ResetMaterialNo() {
	m.material_no = nil
	delete(m.clearedFields, securityjournal.FieldMaterialNo)
}

// SetMaterialName sets the "material_name" field.
func (m *SecurityJournalMutation) SetMaterialName(s string) {
	m.material_name = &s
}

// MaterialName returns the value of the "material_name" field in the mutation.
func (m *SecurityJournalMutation) MaterialName() (r string, exists bool) {
	v := m.material_name
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialName returns the old "material_name" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldMaterialName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialName: %w", err)
	}
	return oldValue.MaterialName, nil
}

// ClearMaterialName clears the value of the "material_name" field.
func (m *SecurityJournalMutation) ClearMaterialName() {
	m.material_name = nil
	m.clearedFields[securityjournal.FieldMaterialName] = struct{}{}
}

// MaterialNameCleared returns if the "material_name" field was cleared in this mutation.
func (m *SecurityJournalMutation) MaterialNameCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldMaterialName]
	return ok
}

// ResetMaterialName resets all changes to the "material_name" field.
func (m *SecurityJournalMutation) ResetMaterialName() {
	m.material_name = nil
	delete(m.clearedFields, securityjournal.FieldMaterialName)
}

// SetMultiplier sets the "multiplier" field.
func (m *SecurityJournalMutation) SetMultiplier(f float64) {
	m.multiplier = &f
	m.addmultiplier = nil
}

// Multiplier returns the value of the "multiplier" field in the mutation.
func (m *SecurityJournalMutation) Multiplier() (r float64, exists bool) {
	v := m.multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiplier returns the old "multiplier" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiplier: %w", err)
	}
	return oldValue.Multiplier, nil
}

// AddMultiplier adds f to the "multiplier" field.
func (m *SecurityJournalMutation) AddMultiplier(f float64) {
	if m.addmultiplier != nil {
		*m.addmultiplier += f
	} else {
		m.addmultiplier = &f
	}
}

// AddedMultiplier returns the value that was added to the "multiplier" field in this mutation.
func (m *SecurityJournalMutation) AddedMultiplier() (r float64, exists bool) {
	v := m.addmultiplier
	if v == nil {
		return
	}
	return *v, true
}

// ClearMultiplier clears the value of the "multiplier" field.
func (m *SecurityJournalMutation) ClearMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
	m.clearedFields[securityjournal.FieldMultiplier] = struct{}{}
}

// MultiplierCleared returns if the "multiplier" field was cleared in this mutation.
func (m *SecurityJournalMutation) MultiplierCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldMultiplier]
	return ok
}

// ResetMultiplier resets all changes to the "multiplier" field.
func (m *SecurityJournalMutation) ResetMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
	delete(m.clearedFields, securityjournal.FieldMultiplier)
}

// SetPositionType sets the "position_type" field.
func (m *SecurityJournalMutation) SetPositionType(i int) {
	m.position_type = &i
	m.addposition_type = nil
}

// PositionType returns the value of the "position_type" field in the mutation.
func (m *SecurityJournalMutation) PositionType() (r int, exists bool) {
	v := m.position_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionType returns the old "position_type" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldPositionType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionType: %w", err)
	}
	return oldValue.PositionType, nil
}

// AddPositionType adds i to the "position_type" field.
func (m *SecurityJournalMutation) AddPositionType(i int) {
	if m.addposition_type != nil {
		*m.addposition_type += i
	} else {
		m.addposition_type = &i
	}
}

// AddedPositionType returns the value that was added to the "position_type" field in this mutation.
func (m *SecurityJournalMutation) AddedPositionType() (r int, exists bool) {
	v := m.addposition_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearPositionType clears the value of the "position_type" field.
func (m *SecurityJournalMutation) ClearPositionType() {
	m.position_type = nil
	m.addposition_type = nil
	m.clearedFields[securityjournal.FieldPositionType] = struct{}{}
}

// PositionTypeCleared returns if the "position_type" field was cleared in this mutation.
func (m *SecurityJournalMutation) PositionTypeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldPositionType]
	return ok
}

// ResetPositionType resets all changes to the "position_type" field.
func (m *SecurityJournalMutation) ResetPositionType() {
	m.position_type = nil
	m.addposition_type = nil
	delete(m.clearedFields, securityjournal.FieldPositionType)
}

// SetCurrency sets the "currency" field.
func (m *SecurityJournalMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *SecurityJournalMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *SecurityJournalMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[securityjournal.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *SecurityJournalMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *SecurityJournalMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, securityjournal.FieldCurrency)
}

// SetQty sets the "qty" field.
func (m *SecurityJournalMutation) SetQty(f float64) {
	m.qty = &f
	m.addqty = nil
}

// Qty returns the value of the "qty" field in the mutation.
func (m *SecurityJournalMutation) Qty() (r float64, exists bool) {
	v := m.qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "qty" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds f to the "qty" field.
func (m *SecurityJournalMutation) AddQty(f float64) {
	if m.addqty != nil {
		*m.addqty += f
	} else {
		m.addqty = &f
	}
}

// AddedQty returns the value that was added to the "qty" field in this mutation.
func (m *SecurityJournalMutation) AddedQty() (r float64, exists bool) {
	v := m.addqty
	if v == nil {
		return
	}
	return *v, true
}

// ClearQty clears the value of the "qty" field.
func (m *SecurityJournalMutation) ClearQty() {
	m.qty = nil
	m.addqty = nil
	m.clearedFields[securityjournal.FieldQty] = struct{}{}
}

// QtyCleared returns if the "qty" field was cleared in this mutation.
func (m *SecurityJournalMutation) QtyCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldQty]
	return ok
}

// ResetQty resets all changes to the "qty" field.
func (m *SecurityJournalMutation) ResetQty() {
	m.qty = nil
	m.addqty = nil
	delete(m.clearedFields, securityjournal.FieldQty)
}

// SetPrice sets the "price" field.
func (m *SecurityJournalMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SecurityJournalMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *SecurityJournalMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SecurityJournalMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *SecurityJournalMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[securityjournal.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *SecurityJournalMutation) PriceCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *SecurityJournalMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, securityjournal.FieldPrice)
}

// SetAmount sets the "amount" field.
func (m *SecurityJournalMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *SecurityJournalMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *SecurityJournalMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *SecurityJournalMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *SecurityJournalMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[securityjournal.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *SecurityJournalMutation) AmountCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *SecurityJournalMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, securityjournal.FieldAmount)
}

// SetCost sets the "cost" field.
func (m *SecurityJournalMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *SecurityJournalMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldCost(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *SecurityJournalMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *SecurityJournalMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ClearCost clears the value of the "cost" field.
func (m *SecurityJournalMutation) ClearCost() {
	m.cost = nil
	m.addcost = nil
	m.clearedFields[securityjournal.FieldCost] = struct{}{}
}

// CostCleared returns if the "cost" field was cleared in this mutation.
func (m *SecurityJournalMutation) CostCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldCost]
	return ok
}

// ResetCost resets all changes to the "cost" field.
func (m *SecurityJournalMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
	delete(m.clearedFields, securityjournal.FieldCost)
}

// SetTotal sets the "total" field.
func (m *SecurityJournalMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *SecurityJournalMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *SecurityJournalMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *SecurityJournalMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *SecurityJournalMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[securityjournal.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *SecurityJournalMutation) TotalCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *SecurityJournalMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, securityjournal.FieldTotal)
}

// SetUnit sets the "unit" field.
func (m *SecurityJournalMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SecurityJournalMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *SecurityJournalMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[securityjournal.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *SecurityJournalMutation) UnitCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *SecurityJournalMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, securityjournal.FieldUnit)
}

// SetSpec sets the "spec" field.
func (m *SecurityJournalMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *SecurityJournalMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldSpec(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ClearSpec clears the value of the "spec" field.
func (m *SecurityJournalMutation) ClearSpec() {
	m.spec = nil
	m.clearedFields[securityjournal.FieldSpec] = struct{}{}
}

// SpecCleared returns if the "spec" field was cleared in this mutation.
func (m *SecurityJournalMutation) SpecCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldSpec]
	return ok
}

// ResetSpec resets all changes to the "spec" field.
func (m *SecurityJournalMutation) ResetSpec() {
	m.spec = nil
	delete(m.clearedFields, securityjournal.FieldSpec)
}

// SetCommission sets the "commission" field.
func (m *SecurityJournalMutation) SetCommission(f float64) {
	m.commission = &f
	m.addcommission = nil
}

// Commission returns the value of the "commission" field in the mutation.
func (m *SecurityJournalMutation) Commission() (r float64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldCommission(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// AddCommission adds f to the "commission" field.
func (m *SecurityJournalMutation) AddCommission(f float64) {
	if m.addcommission != nil {
		*m.addcommission += f
	} else {
		m.addcommission = &f
	}
}

// AddedCommission returns the value that was added to the "commission" field in this mutation.
func (m *SecurityJournalMutation) AddedCommission() (r float64, exists bool) {
	v := m.addcommission
	if v == nil {
		return
	}
	return *v, true
}

// ClearCommission clears the value of the "commission" field.
func (m *SecurityJournalMutation) ClearCommission() {
	m.commission = nil
	m.addcommission = nil
	m.clearedFields[securityjournal.FieldCommission] = struct{}{}
}

// CommissionCleared returns if the "commission" field was cleared in this mutation.
func (m *SecurityJournalMutation) CommissionCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldCommission]
	return ok
}

// ResetCommission resets all changes to the "commission" field.
func (m *SecurityJournalMutation) ResetCommission() {
	m.commission = nil
	m.addcommission = nil
	delete(m.clearedFields, securityjournal.FieldCommission)
}

// SetFee sets the "fee" field.
func (m *SecurityJournalMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *SecurityJournalMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *SecurityJournalMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *SecurityJournalMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *SecurityJournalMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[securityjournal.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *SecurityJournalMutation) FeeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *SecurityJournalMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, securityjournal.FieldFee)
}

// SetFeeOther sets the "fee_other" field.
func (m *SecurityJournalMutation) SetFeeOther(f float64) {
	m.fee_other = &f
	m.addfee_other = nil
}

// FeeOther returns the value of the "fee_other" field in the mutation.
func (m *SecurityJournalMutation) FeeOther() (r float64, exists bool) {
	v := m.fee_other
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeOther returns the old "fee_other" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldFeeOther(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeOther is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeOther requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeOther: %w", err)
	}
	return oldValue.FeeOther, nil
}

// AddFeeOther adds f to the "fee_other" field.
func (m *SecurityJournalMutation) AddFeeOther(f float64) {
	if m.addfee_other != nil {
		*m.addfee_other += f
	} else {
		m.addfee_other = &f
	}
}

// AddedFeeOther returns the value that was added to the "fee_other" field in this mutation.
func (m *SecurityJournalMutation) AddedFeeOther() (r float64, exists bool) {
	v := m.addfee_other
	if v == nil {
		return
	}
	return *v, true
}

// ClearFeeOther clears the value of the "fee_other" field.
func (m *SecurityJournalMutation) ClearFeeOther() {
	m.fee_other = nil
	m.addfee_other = nil
	m.clearedFields[securityjournal.FieldFeeOther] = struct{}{}
}

// FeeOtherCleared returns if the "fee_other" field was cleared in this mutation.
func (m *SecurityJournalMutation) FeeOtherCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldFeeOther]
	return ok
}

// ResetFeeOther resets all changes to the "fee_other" field.
func (m *SecurityJournalMutation) ResetFeeOther() {
	m.fee_other = nil
	m.addfee_other = nil
	delete(m.clearedFields, securityjournal.FieldFeeOther)
}

// SetCount sets the "count" field.
func (m *SecurityJournalMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *SecurityJournalMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *SecurityJournalMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *SecurityJournalMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCount clears the value of the "count" field.
func (m *SecurityJournalMutation) ClearCount() {
	m.count = nil
	m.addcount = nil
	m.clearedFields[securityjournal.FieldCount] = struct{}{}
}

// CountCleared returns if the "count" field was cleared in this mutation.
func (m *SecurityJournalMutation) CountCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldCount]
	return ok
}

// ResetCount resets all changes to the "count" field.
func (m *SecurityJournalMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
	delete(m.clearedFields, securityjournal.FieldCount)
}

// SetDirection sets the "direction" field.
func (m *SecurityJournalMutation) SetDirection(i int) {
	m.direction = &i
	m.adddirection = nil
}

// Direction returns the value of the "direction" field in the mutation.
func (m *SecurityJournalMutation) Direction() (r int, exists bool) {
	v := m.direction
	if v == nil {
		return
	}
	return *v, true
}

// OldDirection returns the old "direction" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldDirection(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirection: %w", err)
	}
	return oldValue.Direction, nil
}

// AddDirection adds i to the "direction" field.
func (m *SecurityJournalMutation) AddDirection(i int) {
	if m.adddirection != nil {
		*m.adddirection += i
	} else {
		m.adddirection = &i
	}
}

// AddedDirection returns the value that was added to the "direction" field in this mutation.
func (m *SecurityJournalMutation) AddedDirection() (r int, exists bool) {
	v := m.adddirection
	if v == nil {
		return
	}
	return *v, true
}

// ClearDirection clears the value of the "direction" field.
func (m *SecurityJournalMutation) ClearDirection() {
	m.direction = nil
	m.adddirection = nil
	m.clearedFields[securityjournal.FieldDirection] = struct{}{}
}

// DirectionCleared returns if the "direction" field was cleared in this mutation.
func (m *SecurityJournalMutation) DirectionCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldDirection]
	return ok
}

// ResetDirection resets all changes to the "direction" field.
func (m *SecurityJournalMutation) ResetDirection() {
	m.direction = nil
	m.adddirection = nil
	delete(m.clearedFields, securityjournal.FieldDirection)
}

// SetTamper sets the "tamper" field.
func (m *SecurityJournalMutation) SetTamper(s string) {
	m.tamper = &s
}

// Tamper returns the value of the "tamper" field in the mutation.
func (m *SecurityJournalMutation) Tamper() (r string, exists bool) {
	v := m.tamper
	if v == nil {
		return
	}
	return *v, true
}

// OldTamper returns the old "tamper" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldTamper(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTamper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTamper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTamper: %w", err)
	}
	return oldValue.Tamper, nil
}

// ClearTamper clears the value of the "tamper" field.
func (m *SecurityJournalMutation) ClearTamper() {
	m.tamper = nil
	m.clearedFields[securityjournal.FieldTamper] = struct{}{}
}

// TamperCleared returns if the "tamper" field was cleared in this mutation.
func (m *SecurityJournalMutation) TamperCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldTamper]
	return ok
}

// ResetTamper resets all changes to the "tamper" field.
func (m *SecurityJournalMutation) ResetTamper() {
	m.tamper = nil
	delete(m.clearedFields, securityjournal.FieldTamper)
}

// SetSummary sets the "summary" field.
func (m *SecurityJournalMutation) SetSummary(s string) {
	m.summary = &s
}

// Summary returns the value of the "summary" field in the mutation.
func (m *SecurityJournalMutation) Summary() (r string, exists bool) {
	v := m.summary
	if v == nil {
		return
	}
	return *v, true
}

// OldSummary returns the old "summary" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldSummary(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSummary: %w", err)
	}
	return oldValue.Summary, nil
}

// ClearSummary clears the value of the "summary" field.
func (m *SecurityJournalMutation) ClearSummary() {
	m.summary = nil
	m.clearedFields[securityjournal.FieldSummary] = struct{}{}
}

// SummaryCleared returns if the "summary" field was cleared in this mutation.
func (m *SecurityJournalMutation) SummaryCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldSummary]
	return ok
}

// ResetSummary resets all changes to the "summary" field.
func (m *SecurityJournalMutation) ResetSummary() {
	m.summary = nil
	delete(m.clearedFields, securityjournal.FieldSummary)
}

// SetPairSubjectCode sets the "pair_subject_code" field.
func (m *SecurityJournalMutation) SetPairSubjectCode(s string) {
	m.pair_subject_code = &s
}

// PairSubjectCode returns the value of the "pair_subject_code" field in the mutation.
func (m *SecurityJournalMutation) PairSubjectCode() (r string, exists bool) {
	v := m.pair_subject_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPairSubjectCode returns the old "pair_subject_code" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldPairSubjectCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPairSubjectCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPairSubjectCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPairSubjectCode: %w", err)
	}
	return oldValue.PairSubjectCode, nil
}

// ClearPairSubjectCode clears the value of the "pair_subject_code" field.
func (m *SecurityJournalMutation) ClearPairSubjectCode() {
	m.pair_subject_code = nil
	m.clearedFields[securityjournal.FieldPairSubjectCode] = struct{}{}
}

// PairSubjectCodeCleared returns if the "pair_subject_code" field was cleared in this mutation.
func (m *SecurityJournalMutation) PairSubjectCodeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldPairSubjectCode]
	return ok
}

// ResetPairSubjectCode resets all changes to the "pair_subject_code" field.
func (m *SecurityJournalMutation) ResetPairSubjectCode() {
	m.pair_subject_code = nil
	delete(m.clearedFields, securityjournal.FieldPairSubjectCode)
}

// SetPairSecurityAccountID sets the "pair_security_account_id" field.
func (m *SecurityJournalMutation) SetPairSecurityAccountID(i int) {
	m.pair_security_account_id = &i
	m.addpair_security_account_id = nil
}

// PairSecurityAccountID returns the value of the "pair_security_account_id" field in the mutation.
func (m *SecurityJournalMutation) PairSecurityAccountID() (r int, exists bool) {
	v := m.pair_security_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPairSecurityAccountID returns the old "pair_security_account_id" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldPairSecurityAccountID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPairSecurityAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPairSecurityAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPairSecurityAccountID: %w", err)
	}
	return oldValue.PairSecurityAccountID, nil
}

// AddPairSecurityAccountID adds i to the "pair_security_account_id" field.
func (m *SecurityJournalMutation) AddPairSecurityAccountID(i int) {
	if m.addpair_security_account_id != nil {
		*m.addpair_security_account_id += i
	} else {
		m.addpair_security_account_id = &i
	}
}

// AddedPairSecurityAccountID returns the value that was added to the "pair_security_account_id" field in this mutation.
func (m *SecurityJournalMutation) AddedPairSecurityAccountID() (r int, exists bool) {
	v := m.addpair_security_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPairSecurityAccountID clears the value of the "pair_security_account_id" field.
func (m *SecurityJournalMutation) ClearPairSecurityAccountID() {
	m.pair_security_account_id = nil
	m.addpair_security_account_id = nil
	m.clearedFields[securityjournal.FieldPairSecurityAccountID] = struct{}{}
}

// PairSecurityAccountIDCleared returns if the "pair_security_account_id" field was cleared in this mutation.
func (m *SecurityJournalMutation) PairSecurityAccountIDCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldPairSecurityAccountID]
	return ok
}

// ResetPairSecurityAccountID resets all changes to the "pair_security_account_id" field.
func (m *SecurityJournalMutation) ResetPairSecurityAccountID() {
	m.pair_security_account_id = nil
	m.addpair_security_account_id = nil
	delete(m.clearedFields, securityjournal.FieldPairSecurityAccountID)
}

// SetLastBalance sets the "last_balance" field.
func (m *SecurityJournalMutation) SetLastBalance(f float64) {
	m.last_balance = &f
	m.addlast_balance = nil
}

// LastBalance returns the value of the "last_balance" field in the mutation.
func (m *SecurityJournalMutation) LastBalance() (r float64, exists bool) {
	v := m.last_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBalance returns the old "last_balance" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldLastBalance(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBalance: %w", err)
	}
	return oldValue.LastBalance, nil
}

// AddLastBalance adds f to the "last_balance" field.
func (m *SecurityJournalMutation) AddLastBalance(f float64) {
	if m.addlast_balance != nil {
		*m.addlast_balance += f
	} else {
		m.addlast_balance = &f
	}
}

// AddedLastBalance returns the value that was added to the "last_balance" field in this mutation.
func (m *SecurityJournalMutation) AddedLastBalance() (r float64, exists bool) {
	v := m.addlast_balance
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastBalance clears the value of the "last_balance" field.
func (m *SecurityJournalMutation) ClearLastBalance() {
	m.last_balance = nil
	m.addlast_balance = nil
	m.clearedFields[securityjournal.FieldLastBalance] = struct{}{}
}

// LastBalanceCleared returns if the "last_balance" field was cleared in this mutation.
func (m *SecurityJournalMutation) LastBalanceCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldLastBalance]
	return ok
}

// ResetLastBalance resets all changes to the "last_balance" field.
func (m *SecurityJournalMutation) ResetLastBalance() {
	m.last_balance = nil
	m.addlast_balance = nil
	delete(m.clearedFields, securityjournal.FieldLastBalance)
}

// SetStlTime sets the "stl_time" field.
func (m *SecurityJournalMutation) SetStlTime(t time.Time) {
	m.stl_time = &t
}

// StlTime returns the value of the "stl_time" field in the mutation.
func (m *SecurityJournalMutation) StlTime() (r time.Time, exists bool) {
	v := m.stl_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStlTime returns the old "stl_time" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldStlTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlTime: %w", err)
	}
	return oldValue.StlTime, nil
}

// ClearStlTime clears the value of the "stl_time" field.
func (m *SecurityJournalMutation) ClearStlTime() {
	m.stl_time = nil
	m.clearedFields[securityjournal.FieldStlTime] = struct{}{}
}

// StlTimeCleared returns if the "stl_time" field was cleared in this mutation.
func (m *SecurityJournalMutation) StlTimeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldStlTime]
	return ok
}

// ResetStlTime resets all changes to the "stl_time" field.
func (m *SecurityJournalMutation) ResetStlTime() {
	m.stl_time = nil
	delete(m.clearedFields, securityjournal.FieldStlTime)
}

// SetFxRate sets the "fx_rate" field.
func (m *SecurityJournalMutation) SetFxRate(f float64) {
	m.fx_rate = &f
	m.addfx_rate = nil
}

// FxRate returns the value of the "fx_rate" field in the mutation.
func (m *SecurityJournalMutation) FxRate() (r float64, exists bool) {
	v := m.fx_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFxRate returns the old "fx_rate" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldFxRate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFxRate: %w", err)
	}
	return oldValue.FxRate, nil
}

// AddFxRate adds f to the "fx_rate" field.
func (m *SecurityJournalMutation) AddFxRate(f float64) {
	if m.addfx_rate != nil {
		*m.addfx_rate += f
	} else {
		m.addfx_rate = &f
	}
}

// AddedFxRate returns the value that was added to the "fx_rate" field in this mutation.
func (m *SecurityJournalMutation) AddedFxRate() (r float64, exists bool) {
	v := m.addfx_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearFxRate clears the value of the "fx_rate" field.
func (m *SecurityJournalMutation) ClearFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	m.clearedFields[securityjournal.FieldFxRate] = struct{}{}
}

// FxRateCleared returns if the "fx_rate" field was cleared in this mutation.
func (m *SecurityJournalMutation) FxRateCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldFxRate]
	return ok
}

// ResetFxRate resets all changes to the "fx_rate" field.
func (m *SecurityJournalMutation) ResetFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	delete(m.clearedFields, securityjournal.FieldFxRate)
}

// SetStlCurrency sets the "stl_currency" field.
func (m *SecurityJournalMutation) SetStlCurrency(s string) {
	m.stl_currency = &s
}

// StlCurrency returns the value of the "stl_currency" field in the mutation.
func (m *SecurityJournalMutation) StlCurrency() (r string, exists bool) {
	v := m.stl_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldStlCurrency returns the old "stl_currency" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldStlCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlCurrency: %w", err)
	}
	return oldValue.StlCurrency, nil
}

// ClearStlCurrency clears the value of the "stl_currency" field.
func (m *SecurityJournalMutation) ClearStlCurrency() {
	m.stl_currency = nil
	m.clearedFields[securityjournal.FieldStlCurrency] = struct{}{}
}

// StlCurrencyCleared returns if the "stl_currency" field was cleared in this mutation.
func (m *SecurityJournalMutation) StlCurrencyCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldStlCurrency]
	return ok
}

// ResetStlCurrency resets all changes to the "stl_currency" field.
func (m *SecurityJournalMutation) ResetStlCurrency() {
	m.stl_currency = nil
	delete(m.clearedFields, securityjournal.FieldStlCurrency)
}

// SetStlAmount sets the "stl_amount" field.
func (m *SecurityJournalMutation) SetStlAmount(f float64) {
	m.stl_amount = &f
	m.addstl_amount = nil
}

// StlAmount returns the value of the "stl_amount" field in the mutation.
func (m *SecurityJournalMutation) StlAmount() (r float64, exists bool) {
	v := m.stl_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStlAmount returns the old "stl_amount" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldStlAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlAmount: %w", err)
	}
	return oldValue.StlAmount, nil
}

// AddStlAmount adds f to the "stl_amount" field.
func (m *SecurityJournalMutation) AddStlAmount(f float64) {
	if m.addstl_amount != nil {
		*m.addstl_amount += f
	} else {
		m.addstl_amount = &f
	}
}

// AddedStlAmount returns the value that was added to the "stl_amount" field in this mutation.
func (m *SecurityJournalMutation) AddedStlAmount() (r float64, exists bool) {
	v := m.addstl_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlAmount clears the value of the "stl_amount" field.
func (m *SecurityJournalMutation) ClearStlAmount() {
	m.stl_amount = nil
	m.addstl_amount = nil
	m.clearedFields[securityjournal.FieldStlAmount] = struct{}{}
}

// StlAmountCleared returns if the "stl_amount" field was cleared in this mutation.
func (m *SecurityJournalMutation) StlAmountCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldStlAmount]
	return ok
}

// ResetStlAmount resets all changes to the "stl_amount" field.
func (m *SecurityJournalMutation) ResetStlAmount() {
	m.stl_amount = nil
	m.addstl_amount = nil
	delete(m.clearedFields, securityjournal.FieldStlAmount)
}

// SetStlMarginLv sets the "stl_margin_lv" field.
func (m *SecurityJournalMutation) SetStlMarginLv(f float64) {
	m.stl_margin_lv = &f
	m.addstl_margin_lv = nil
}

// StlMarginLv returns the value of the "stl_margin_lv" field in the mutation.
func (m *SecurityJournalMutation) StlMarginLv() (r float64, exists bool) {
	v := m.stl_margin_lv
	if v == nil {
		return
	}
	return *v, true
}

// OldStlMarginLv returns the old "stl_margin_lv" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldStlMarginLv(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlMarginLv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlMarginLv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlMarginLv: %w", err)
	}
	return oldValue.StlMarginLv, nil
}

// AddStlMarginLv adds f to the "stl_margin_lv" field.
func (m *SecurityJournalMutation) AddStlMarginLv(f float64) {
	if m.addstl_margin_lv != nil {
		*m.addstl_margin_lv += f
	} else {
		m.addstl_margin_lv = &f
	}
}

// AddedStlMarginLv returns the value that was added to the "stl_margin_lv" field in this mutation.
func (m *SecurityJournalMutation) AddedStlMarginLv() (r float64, exists bool) {
	v := m.addstl_margin_lv
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlMarginLv clears the value of the "stl_margin_lv" field.
func (m *SecurityJournalMutation) ClearStlMarginLv() {
	m.stl_margin_lv = nil
	m.addstl_margin_lv = nil
	m.clearedFields[securityjournal.FieldStlMarginLv] = struct{}{}
}

// StlMarginLvCleared returns if the "stl_margin_lv" field was cleared in this mutation.
func (m *SecurityJournalMutation) StlMarginLvCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldStlMarginLv]
	return ok
}

// ResetStlMarginLv resets all changes to the "stl_margin_lv" field.
func (m *SecurityJournalMutation) ResetStlMarginLv() {
	m.stl_margin_lv = nil
	m.addstl_margin_lv = nil
	delete(m.clearedFields, securityjournal.FieldStlMarginLv)
}

// SetIsSettlement sets the "is_settlement" field.
func (m *SecurityJournalMutation) SetIsSettlement(s string) {
	m.is_settlement = &s
}

// IsSettlement returns the value of the "is_settlement" field in the mutation.
func (m *SecurityJournalMutation) IsSettlement() (r string, exists bool) {
	v := m.is_settlement
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSettlement returns the old "is_settlement" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldIsSettlement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsSettlement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsSettlement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSettlement: %w", err)
	}
	return oldValue.IsSettlement, nil
}

// ClearIsSettlement clears the value of the "is_settlement" field.
func (m *SecurityJournalMutation) ClearIsSettlement() {
	m.is_settlement = nil
	m.clearedFields[securityjournal.FieldIsSettlement] = struct{}{}
}

// IsSettlementCleared returns if the "is_settlement" field was cleared in this mutation.
func (m *SecurityJournalMutation) IsSettlementCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldIsSettlement]
	return ok
}

// ResetIsSettlement resets all changes to the "is_settlement" field.
func (m *SecurityJournalMutation) ResetIsSettlement() {
	m.is_settlement = nil
	delete(m.clearedFields, securityjournal.FieldIsSettlement)
}

// SetActualStlTime sets the "actual_stl_time" field.
func (m *SecurityJournalMutation) SetActualStlTime(t time.Time) {
	m.actual_stl_time = &t
}

// ActualStlTime returns the value of the "actual_stl_time" field in the mutation.
func (m *SecurityJournalMutation) ActualStlTime() (r time.Time, exists bool) {
	v := m.actual_stl_time
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStlTime returns the old "actual_stl_time" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldActualStlTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualStlTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualStlTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStlTime: %w", err)
	}
	return oldValue.ActualStlTime, nil
}

// ClearActualStlTime clears the value of the "actual_stl_time" field.
func (m *SecurityJournalMutation) ClearActualStlTime() {
	m.actual_stl_time = nil
	m.clearedFields[securityjournal.FieldActualStlTime] = struct{}{}
}

// ActualStlTimeCleared returns if the "actual_stl_time" field was cleared in this mutation.
func (m *SecurityJournalMutation) ActualStlTimeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldActualStlTime]
	return ok
}

// ResetActualStlTime resets all changes to the "actual_stl_time" field.
func (m *SecurityJournalMutation) ResetActualStlTime() {
	m.actual_stl_time = nil
	delete(m.clearedFields, securityjournal.FieldActualStlTime)
}

// SetTransNo sets the "trans_no" field.
func (m *SecurityJournalMutation) SetTransNo(s string) {
	m.trans_no = &s
}

// TransNo returns the value of the "trans_no" field in the mutation.
func (m *SecurityJournalMutation) TransNo() (r string, exists bool) {
	v := m.trans_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTransNo returns the old "trans_no" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldTransNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransNo: %w", err)
	}
	return oldValue.TransNo, nil
}

// ClearTransNo clears the value of the "trans_no" field.
func (m *SecurityJournalMutation) ClearTransNo() {
	m.trans_no = nil
	m.clearedFields[securityjournal.FieldTransNo] = struct{}{}
}

// TransNoCleared returns if the "trans_no" field was cleared in this mutation.
func (m *SecurityJournalMutation) TransNoCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldTransNo]
	return ok
}

// ResetTransNo resets all changes to the "trans_no" field.
func (m *SecurityJournalMutation) ResetTransNo() {
	m.trans_no = nil
	delete(m.clearedFields, securityjournal.FieldTransNo)
}

// SetTransTime sets the "trans_time" field.
func (m *SecurityJournalMutation) SetTransTime(t time.Time) {
	m.trans_time = &t
}

// TransTime returns the value of the "trans_time" field in the mutation.
func (m *SecurityJournalMutation) TransTime() (r time.Time, exists bool) {
	v := m.trans_time
	if v == nil {
		return
	}
	return *v, true
}

// OldTransTime returns the old "trans_time" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldTransTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransTime: %w", err)
	}
	return oldValue.TransTime, nil
}

// ClearTransTime clears the value of the "trans_time" field.
func (m *SecurityJournalMutation) ClearTransTime() {
	m.trans_time = nil
	m.clearedFields[securityjournal.FieldTransTime] = struct{}{}
}

// TransTimeCleared returns if the "trans_time" field was cleared in this mutation.
func (m *SecurityJournalMutation) TransTimeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldTransTime]
	return ok
}

// ResetTransTime resets all changes to the "trans_time" field.
func (m *SecurityJournalMutation) ResetTransTime() {
	m.trans_time = nil
	delete(m.clearedFields, securityjournal.FieldTransTime)
}

// SetAccountingNo sets the "accounting_no" field.
func (m *SecurityJournalMutation) SetAccountingNo(s string) {
	m.accounting_no = &s
}

// AccountingNo returns the value of the "accounting_no" field in the mutation.
func (m *SecurityJournalMutation) AccountingNo() (r string, exists bool) {
	v := m.accounting_no
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingNo returns the old "accounting_no" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldAccountingNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountingNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountingNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingNo: %w", err)
	}
	return oldValue.AccountingNo, nil
}

// ClearAccountingNo clears the value of the "accounting_no" field.
func (m *SecurityJournalMutation) ClearAccountingNo() {
	m.accounting_no = nil
	m.clearedFields[securityjournal.FieldAccountingNo] = struct{}{}
}

// AccountingNoCleared returns if the "accounting_no" field was cleared in this mutation.
func (m *SecurityJournalMutation) AccountingNoCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldAccountingNo]
	return ok
}

// ResetAccountingNo resets all changes to the "accounting_no" field.
func (m *SecurityJournalMutation) ResetAccountingNo() {
	m.accounting_no = nil
	delete(m.clearedFields, securityjournal.FieldAccountingNo)
}

// SetAccountingTime sets the "accounting_time" field.
func (m *SecurityJournalMutation) SetAccountingTime(t time.Time) {
	m.accounting_time = &t
}

// AccountingTime returns the value of the "accounting_time" field in the mutation.
func (m *SecurityJournalMutation) AccountingTime() (r time.Time, exists bool) {
	v := m.accounting_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountingTime returns the old "accounting_time" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldAccountingTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountingTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountingTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountingTime: %w", err)
	}
	return oldValue.AccountingTime, nil
}

// ClearAccountingTime clears the value of the "accounting_time" field.
func (m *SecurityJournalMutation) ClearAccountingTime() {
	m.accounting_time = nil
	m.clearedFields[securityjournal.FieldAccountingTime] = struct{}{}
}

// AccountingTimeCleared returns if the "accounting_time" field was cleared in this mutation.
func (m *SecurityJournalMutation) AccountingTimeCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldAccountingTime]
	return ok
}

// ResetAccountingTime resets all changes to the "accounting_time" field.
func (m *SecurityJournalMutation) ResetAccountingTime() {
	m.accounting_time = nil
	delete(m.clearedFields, securityjournal.FieldAccountingTime)
}

// SetAccountedPositionQty sets the "accounted_position_qty" field.
func (m *SecurityJournalMutation) SetAccountedPositionQty(f float64) {
	m.accounted_position_qty = &f
	m.addaccounted_position_qty = nil
}

// AccountedPositionQty returns the value of the "accounted_position_qty" field in the mutation.
func (m *SecurityJournalMutation) AccountedPositionQty() (r float64, exists bool) {
	v := m.accounted_position_qty
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountedPositionQty returns the old "accounted_position_qty" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldAccountedPositionQty(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountedPositionQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountedPositionQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountedPositionQty: %w", err)
	}
	return oldValue.AccountedPositionQty, nil
}

// AddAccountedPositionQty adds f to the "accounted_position_qty" field.
func (m *SecurityJournalMutation) AddAccountedPositionQty(f float64) {
	if m.addaccounted_position_qty != nil {
		*m.addaccounted_position_qty += f
	} else {
		m.addaccounted_position_qty = &f
	}
}

// AddedAccountedPositionQty returns the value that was added to the "accounted_position_qty" field in this mutation.
func (m *SecurityJournalMutation) AddedAccountedPositionQty() (r float64, exists bool) {
	v := m.addaccounted_position_qty
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccountedPositionQty clears the value of the "accounted_position_qty" field.
func (m *SecurityJournalMutation) ClearAccountedPositionQty() {
	m.accounted_position_qty = nil
	m.addaccounted_position_qty = nil
	m.clearedFields[securityjournal.FieldAccountedPositionQty] = struct{}{}
}

// AccountedPositionQtyCleared returns if the "accounted_position_qty" field was cleared in this mutation.
func (m *SecurityJournalMutation) AccountedPositionQtyCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldAccountedPositionQty]
	return ok
}

// ResetAccountedPositionQty resets all changes to the "accounted_position_qty" field.
func (m *SecurityJournalMutation) ResetAccountedPositionQty() {
	m.accounted_position_qty = nil
	m.addaccounted_position_qty = nil
	delete(m.clearedFields, securityjournal.FieldAccountedPositionQty)
}

// SetCdDirection sets the "cd_direction" field.
func (m *SecurityJournalMutation) SetCdDirection(i int) {
	m.cd_direction = &i
	m.addcd_direction = nil
}

// CdDirection returns the value of the "cd_direction" field in the mutation.
func (m *SecurityJournalMutation) CdDirection() (r int, exists bool) {
	v := m.cd_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldCdDirection returns the old "cd_direction" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldCdDirection(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdDirection: %w", err)
	}
	return oldValue.CdDirection, nil
}

// AddCdDirection adds i to the "cd_direction" field.
func (m *SecurityJournalMutation) AddCdDirection(i int) {
	if m.addcd_direction != nil {
		*m.addcd_direction += i
	} else {
		m.addcd_direction = &i
	}
}

// AddedCdDirection returns the value that was added to the "cd_direction" field in this mutation.
func (m *SecurityJournalMutation) AddedCdDirection() (r int, exists bool) {
	v := m.addcd_direction
	if v == nil {
		return
	}
	return *v, true
}

// ClearCdDirection clears the value of the "cd_direction" field.
func (m *SecurityJournalMutation) ClearCdDirection() {
	m.cd_direction = nil
	m.addcd_direction = nil
	m.clearedFields[securityjournal.FieldCdDirection] = struct{}{}
}

// CdDirectionCleared returns if the "cd_direction" field was cleared in this mutation.
func (m *SecurityJournalMutation) CdDirectionCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldCdDirection]
	return ok
}

// ResetCdDirection resets all changes to the "cd_direction" field.
func (m *SecurityJournalMutation) ResetCdDirection() {
	m.cd_direction = nil
	m.addcd_direction = nil
	delete(m.clearedFields, securityjournal.FieldCdDirection)
}

// SetApplyFields sets the "apply_fields" field.
func (m *SecurityJournalMutation) SetApplyFields(s string) {
	m.apply_fields = &s
}

// ApplyFields returns the value of the "apply_fields" field in the mutation.
func (m *SecurityJournalMutation) ApplyFields() (r string, exists bool) {
	v := m.apply_fields
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyFields returns the old "apply_fields" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldApplyFields(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyFields is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyFields requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyFields: %w", err)
	}
	return oldValue.ApplyFields, nil
}

// ClearApplyFields clears the value of the "apply_fields" field.
func (m *SecurityJournalMutation) ClearApplyFields() {
	m.apply_fields = nil
	m.clearedFields[securityjournal.FieldApplyFields] = struct{}{}
}

// ApplyFieldsCleared returns if the "apply_fields" field was cleared in this mutation.
func (m *SecurityJournalMutation) ApplyFieldsCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldApplyFields]
	return ok
}

// ResetApplyFields resets all changes to the "apply_fields" field.
func (m *SecurityJournalMutation) ResetApplyFields() {
	m.apply_fields = nil
	delete(m.clearedFields, securityjournal.FieldApplyFields)
}

// SetCreatedAt sets the "created_at" field.
func (m *SecurityJournalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SecurityJournalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SecurityJournalMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[securityjournal.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SecurityJournalMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SecurityJournalMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, securityjournal.FieldCreatedAt)
}

// SetRefTransNo sets the "ref_trans_no" field.
func (m *SecurityJournalMutation) SetRefTransNo(s string) {
	m.ref_trans_no = &s
}

// RefTransNo returns the value of the "ref_trans_no" field in the mutation.
func (m *SecurityJournalMutation) RefTransNo() (r string, exists bool) {
	v := m.ref_trans_no
	if v == nil {
		return
	}
	return *v, true
}

// OldRefTransNo returns the old "ref_trans_no" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldRefTransNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefTransNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefTransNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefTransNo: %w", err)
	}
	return oldValue.RefTransNo, nil
}

// ClearRefTransNo clears the value of the "ref_trans_no" field.
func (m *SecurityJournalMutation) ClearRefTransNo() {
	m.ref_trans_no = nil
	m.clearedFields[securityjournal.FieldRefTransNo] = struct{}{}
}

// RefTransNoCleared returns if the "ref_trans_no" field was cleared in this mutation.
func (m *SecurityJournalMutation) RefTransNoCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldRefTransNo]
	return ok
}

// ResetRefTransNo resets all changes to the "ref_trans_no" field.
func (m *SecurityJournalMutation) ResetRefTransNo() {
	m.ref_trans_no = nil
	delete(m.clearedFields, securityjournal.FieldRefTransNo)
}

// SetIsDayBooking sets the "is_day_booking" field.
func (m *SecurityJournalMutation) SetIsDayBooking(s string) {
	m.is_day_booking = &s
}

// IsDayBooking returns the value of the "is_day_booking" field in the mutation.
func (m *SecurityJournalMutation) IsDayBooking() (r string, exists bool) {
	v := m.is_day_booking
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDayBooking returns the old "is_day_booking" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldIsDayBooking(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDayBooking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDayBooking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDayBooking: %w", err)
	}
	return oldValue.IsDayBooking, nil
}

// ClearIsDayBooking clears the value of the "is_day_booking" field.
func (m *SecurityJournalMutation) ClearIsDayBooking() {
	m.is_day_booking = nil
	m.clearedFields[securityjournal.FieldIsDayBooking] = struct{}{}
}

// IsDayBookingCleared returns if the "is_day_booking" field was cleared in this mutation.
func (m *SecurityJournalMutation) IsDayBookingCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldIsDayBooking]
	return ok
}

// ResetIsDayBooking resets all changes to the "is_day_booking" field.
func (m *SecurityJournalMutation) ResetIsDayBooking() {
	m.is_day_booking = nil
	delete(m.clearedFields, securityjournal.FieldIsDayBooking)
}

// SetIsEffectFund sets the "is_effect_fund" field.
func (m *SecurityJournalMutation) SetIsEffectFund(s string) {
	m.is_effect_fund = &s
}

// IsEffectFund returns the value of the "is_effect_fund" field in the mutation.
func (m *SecurityJournalMutation) IsEffectFund() (r string, exists bool) {
	v := m.is_effect_fund
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEffectFund returns the old "is_effect_fund" field's value of the SecurityJournal entity.
// If the SecurityJournal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityJournalMutation) OldIsEffectFund(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEffectFund is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEffectFund requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEffectFund: %w", err)
	}
	return oldValue.IsEffectFund, nil
}

// ClearIsEffectFund clears the value of the "is_effect_fund" field.
func (m *SecurityJournalMutation) ClearIsEffectFund() {
	m.is_effect_fund = nil
	m.clearedFields[securityjournal.FieldIsEffectFund] = struct{}{}
}

// IsEffectFundCleared returns if the "is_effect_fund" field was cleared in this mutation.
func (m *SecurityJournalMutation) IsEffectFundCleared() bool {
	_, ok := m.clearedFields[securityjournal.FieldIsEffectFund]
	return ok
}

// ResetIsEffectFund resets all changes to the "is_effect_fund" field.
func (m *SecurityJournalMutation) ResetIsEffectFund() {
	m.is_effect_fund = nil
	delete(m.clearedFields, securityjournal.FieldIsEffectFund)
}

// Where appends a list predicates to the SecurityJournalMutation builder.
func (m *SecurityJournalMutation) Where(ps ...predicate.SecurityJournal) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SecurityJournalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SecurityJournal).
func (m *SecurityJournalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityJournalMutation) Fields() []string {
	fields := make([]string, 0, 51)
	if m.security_account_id != nil {
		fields = append(fields, securityjournal.FieldSecurityAccountID)
	}
	if m.account_id != nil {
		fields = append(fields, securityjournal.FieldAccountID)
	}
	if m.biz_no != nil {
		fields = append(fields, securityjournal.FieldBizNo)
	}
	if m.biz_type != nil {
		fields = append(fields, securityjournal.FieldBizType)
	}
	if m.org_id != nil {
		fields = append(fields, securityjournal.FieldOrgID)
	}
	if m.trade_code != nil {
		fields = append(fields, securityjournal.FieldTradeCode)
	}
	if m.change_type != nil {
		fields = append(fields, securityjournal.FieldChangeType)
	}
	if m.record_method_id != nil {
		fields = append(fields, securityjournal.FieldRecordMethodID)
	}
	if m.project_id != nil {
		fields = append(fields, securityjournal.FieldProjectID)
	}
	if m.product_id != nil {
		fields = append(fields, securityjournal.FieldProductID)
	}
	if m.material_id != nil {
		fields = append(fields, securityjournal.FieldMaterialID)
	}
	if m.material_no != nil {
		fields = append(fields, securityjournal.FieldMaterialNo)
	}
	if m.material_name != nil {
		fields = append(fields, securityjournal.FieldMaterialName)
	}
	if m.multiplier != nil {
		fields = append(fields, securityjournal.FieldMultiplier)
	}
	if m.position_type != nil {
		fields = append(fields, securityjournal.FieldPositionType)
	}
	if m.currency != nil {
		fields = append(fields, securityjournal.FieldCurrency)
	}
	if m.qty != nil {
		fields = append(fields, securityjournal.FieldQty)
	}
	if m.price != nil {
		fields = append(fields, securityjournal.FieldPrice)
	}
	if m.amount != nil {
		fields = append(fields, securityjournal.FieldAmount)
	}
	if m.cost != nil {
		fields = append(fields, securityjournal.FieldCost)
	}
	if m.total != nil {
		fields = append(fields, securityjournal.FieldTotal)
	}
	if m.unit != nil {
		fields = append(fields, securityjournal.FieldUnit)
	}
	if m.spec != nil {
		fields = append(fields, securityjournal.FieldSpec)
	}
	if m.commission != nil {
		fields = append(fields, securityjournal.FieldCommission)
	}
	if m.fee != nil {
		fields = append(fields, securityjournal.FieldFee)
	}
	if m.fee_other != nil {
		fields = append(fields, securityjournal.FieldFeeOther)
	}
	if m.count != nil {
		fields = append(fields, securityjournal.FieldCount)
	}
	if m.direction != nil {
		fields = append(fields, securityjournal.FieldDirection)
	}
	if m.tamper != nil {
		fields = append(fields, securityjournal.FieldTamper)
	}
	if m.summary != nil {
		fields = append(fields, securityjournal.FieldSummary)
	}
	if m.pair_subject_code != nil {
		fields = append(fields, securityjournal.FieldPairSubjectCode)
	}
	if m.pair_security_account_id != nil {
		fields = append(fields, securityjournal.FieldPairSecurityAccountID)
	}
	if m.last_balance != nil {
		fields = append(fields, securityjournal.FieldLastBalance)
	}
	if m.stl_time != nil {
		fields = append(fields, securityjournal.FieldStlTime)
	}
	if m.fx_rate != nil {
		fields = append(fields, securityjournal.FieldFxRate)
	}
	if m.stl_currency != nil {
		fields = append(fields, securityjournal.FieldStlCurrency)
	}
	if m.stl_amount != nil {
		fields = append(fields, securityjournal.FieldStlAmount)
	}
	if m.stl_margin_lv != nil {
		fields = append(fields, securityjournal.FieldStlMarginLv)
	}
	if m.is_settlement != nil {
		fields = append(fields, securityjournal.FieldIsSettlement)
	}
	if m.actual_stl_time != nil {
		fields = append(fields, securityjournal.FieldActualStlTime)
	}
	if m.trans_no != nil {
		fields = append(fields, securityjournal.FieldTransNo)
	}
	if m.trans_time != nil {
		fields = append(fields, securityjournal.FieldTransTime)
	}
	if m.accounting_no != nil {
		fields = append(fields, securityjournal.FieldAccountingNo)
	}
	if m.accounting_time != nil {
		fields = append(fields, securityjournal.FieldAccountingTime)
	}
	if m.accounted_position_qty != nil {
		fields = append(fields, securityjournal.FieldAccountedPositionQty)
	}
	if m.cd_direction != nil {
		fields = append(fields, securityjournal.FieldCdDirection)
	}
	if m.apply_fields != nil {
		fields = append(fields, securityjournal.FieldApplyFields)
	}
	if m.created_at != nil {
		fields = append(fields, securityjournal.FieldCreatedAt)
	}
	if m.ref_trans_no != nil {
		fields = append(fields, securityjournal.FieldRefTransNo)
	}
	if m.is_day_booking != nil {
		fields = append(fields, securityjournal.FieldIsDayBooking)
	}
	if m.is_effect_fund != nil {
		fields = append(fields, securityjournal.FieldIsEffectFund)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityJournalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securityjournal.FieldSecurityAccountID:
		return m.SecurityAccountID()
	case securityjournal.FieldAccountID:
		return m.AccountID()
	case securityjournal.FieldBizNo:
		return m.BizNo()
	case securityjournal.FieldBizType:
		return m.BizType()
	case securityjournal.FieldOrgID:
		return m.OrgID()
	case securityjournal.FieldTradeCode:
		return m.TradeCode()
	case securityjournal.FieldChangeType:
		return m.ChangeType()
	case securityjournal.FieldRecordMethodID:
		return m.RecordMethodID()
	case securityjournal.FieldProjectID:
		return m.ProjectID()
	case securityjournal.FieldProductID:
		return m.ProductID()
	case securityjournal.FieldMaterialID:
		return m.MaterialID()
	case securityjournal.FieldMaterialNo:
		return m.MaterialNo()
	case securityjournal.FieldMaterialName:
		return m.MaterialName()
	case securityjournal.FieldMultiplier:
		return m.Multiplier()
	case securityjournal.FieldPositionType:
		return m.PositionType()
	case securityjournal.FieldCurrency:
		return m.Currency()
	case securityjournal.FieldQty:
		return m.Qty()
	case securityjournal.FieldPrice:
		return m.Price()
	case securityjournal.FieldAmount:
		return m.Amount()
	case securityjournal.FieldCost:
		return m.Cost()
	case securityjournal.FieldTotal:
		return m.Total()
	case securityjournal.FieldUnit:
		return m.Unit()
	case securityjournal.FieldSpec:
		return m.Spec()
	case securityjournal.FieldCommission:
		return m.Commission()
	case securityjournal.FieldFee:
		return m.Fee()
	case securityjournal.FieldFeeOther:
		return m.FeeOther()
	case securityjournal.FieldCount:
		return m.Count()
	case securityjournal.FieldDirection:
		return m.Direction()
	case securityjournal.FieldTamper:
		return m.Tamper()
	case securityjournal.FieldSummary:
		return m.Summary()
	case securityjournal.FieldPairSubjectCode:
		return m.PairSubjectCode()
	case securityjournal.FieldPairSecurityAccountID:
		return m.PairSecurityAccountID()
	case securityjournal.FieldLastBalance:
		return m.LastBalance()
	case securityjournal.FieldStlTime:
		return m.StlTime()
	case securityjournal.FieldFxRate:
		return m.FxRate()
	case securityjournal.FieldStlCurrency:
		return m.StlCurrency()
	case securityjournal.FieldStlAmount:
		return m.StlAmount()
	case securityjournal.FieldStlMarginLv:
		return m.StlMarginLv()
	case securityjournal.FieldIsSettlement:
		return m.IsSettlement()
	case securityjournal.FieldActualStlTime:
		return m.ActualStlTime()
	case securityjournal.FieldTransNo:
		return m.TransNo()
	case securityjournal.FieldTransTime:
		return m.TransTime()
	case securityjournal.FieldAccountingNo:
		return m.AccountingNo()
	case securityjournal.FieldAccountingTime:
		return m.AccountingTime()
	case securityjournal.FieldAccountedPositionQty:
		return m.AccountedPositionQty()
	case securityjournal.FieldCdDirection:
		return m.CdDirection()
	case securityjournal.FieldApplyFields:
		return m.ApplyFields()
	case securityjournal.FieldCreatedAt:
		return m.CreatedAt()
	case securityjournal.FieldRefTransNo:
		return m.RefTransNo()
	case securityjournal.FieldIsDayBooking:
		return m.IsDayBooking()
	case securityjournal.FieldIsEffectFund:
		return m.IsEffectFund()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityJournalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securityjournal.FieldSecurityAccountID:
		return m.OldSecurityAccountID(ctx)
	case securityjournal.FieldAccountID:
		return m.OldAccountID(ctx)
	case securityjournal.FieldBizNo:
		return m.OldBizNo(ctx)
	case securityjournal.FieldBizType:
		return m.OldBizType(ctx)
	case securityjournal.FieldOrgID:
		return m.OldOrgID(ctx)
	case securityjournal.FieldTradeCode:
		return m.OldTradeCode(ctx)
	case securityjournal.FieldChangeType:
		return m.OldChangeType(ctx)
	case securityjournal.FieldRecordMethodID:
		return m.OldRecordMethodID(ctx)
	case securityjournal.FieldProjectID:
		return m.OldProjectID(ctx)
	case securityjournal.FieldProductID:
		return m.OldProductID(ctx)
	case securityjournal.FieldMaterialID:
		return m.OldMaterialID(ctx)
	case securityjournal.FieldMaterialNo:
		return m.OldMaterialNo(ctx)
	case securityjournal.FieldMaterialName:
		return m.OldMaterialName(ctx)
	case securityjournal.FieldMultiplier:
		return m.OldMultiplier(ctx)
	case securityjournal.FieldPositionType:
		return m.OldPositionType(ctx)
	case securityjournal.FieldCurrency:
		return m.OldCurrency(ctx)
	case securityjournal.FieldQty:
		return m.OldQty(ctx)
	case securityjournal.FieldPrice:
		return m.OldPrice(ctx)
	case securityjournal.FieldAmount:
		return m.OldAmount(ctx)
	case securityjournal.FieldCost:
		return m.OldCost(ctx)
	case securityjournal.FieldTotal:
		return m.OldTotal(ctx)
	case securityjournal.FieldUnit:
		return m.OldUnit(ctx)
	case securityjournal.FieldSpec:
		return m.OldSpec(ctx)
	case securityjournal.FieldCommission:
		return m.OldCommission(ctx)
	case securityjournal.FieldFee:
		return m.OldFee(ctx)
	case securityjournal.FieldFeeOther:
		return m.OldFeeOther(ctx)
	case securityjournal.FieldCount:
		return m.OldCount(ctx)
	case securityjournal.FieldDirection:
		return m.OldDirection(ctx)
	case securityjournal.FieldTamper:
		return m.OldTamper(ctx)
	case securityjournal.FieldSummary:
		return m.OldSummary(ctx)
	case securityjournal.FieldPairSubjectCode:
		return m.OldPairSubjectCode(ctx)
	case securityjournal.FieldPairSecurityAccountID:
		return m.OldPairSecurityAccountID(ctx)
	case securityjournal.FieldLastBalance:
		return m.OldLastBalance(ctx)
	case securityjournal.FieldStlTime:
		return m.OldStlTime(ctx)
	case securityjournal.FieldFxRate:
		return m.OldFxRate(ctx)
	case securityjournal.FieldStlCurrency:
		return m.OldStlCurrency(ctx)
	case securityjournal.FieldStlAmount:
		return m.OldStlAmount(ctx)
	case securityjournal.FieldStlMarginLv:
		return m.OldStlMarginLv(ctx)
	case securityjournal.FieldIsSettlement:
		return m.OldIsSettlement(ctx)
	case securityjournal.FieldActualStlTime:
		return m.OldActualStlTime(ctx)
	case securityjournal.FieldTransNo:
		return m.OldTransNo(ctx)
	case securityjournal.FieldTransTime:
		return m.OldTransTime(ctx)
	case securityjournal.FieldAccountingNo:
		return m.OldAccountingNo(ctx)
	case securityjournal.FieldAccountingTime:
		return m.OldAccountingTime(ctx)
	case securityjournal.FieldAccountedPositionQty:
		return m.OldAccountedPositionQty(ctx)
	case securityjournal.FieldCdDirection:
		return m.OldCdDirection(ctx)
	case securityjournal.FieldApplyFields:
		return m.OldApplyFields(ctx)
	case securityjournal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case securityjournal.FieldRefTransNo:
		return m.OldRefTransNo(ctx)
	case securityjournal.FieldIsDayBooking:
		return m.OldIsDayBooking(ctx)
	case securityjournal.FieldIsEffectFund:
		return m.OldIsEffectFund(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityJournal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityJournalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securityjournal.FieldSecurityAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityAccountID(v)
		return nil
	case securityjournal.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case securityjournal.FieldBizNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizNo(v)
		return nil
	case securityjournal.FieldBizType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizType(v)
		return nil
	case securityjournal.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	case securityjournal.FieldTradeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeCode(v)
		return nil
	case securityjournal.FieldChangeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeType(v)
		return nil
	case securityjournal.FieldRecordMethodID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecordMethodID(v)
		return nil
	case securityjournal.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case securityjournal.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case securityjournal.FieldMaterialID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialID(v)
		return nil
	case securityjournal.FieldMaterialNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialNo(v)
		return nil
	case securityjournal.FieldMaterialName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialName(v)
		return nil
	case securityjournal.FieldMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiplier(v)
		return nil
	case securityjournal.FieldPositionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionType(v)
		return nil
	case securityjournal.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case securityjournal.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	case securityjournal.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case securityjournal.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case securityjournal.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case securityjournal.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case securityjournal.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case securityjournal.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case securityjournal.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	case securityjournal.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case securityjournal.FieldFeeOther:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeOther(v)
		return nil
	case securityjournal.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case securityjournal.FieldDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirection(v)
		return nil
	case securityjournal.FieldTamper:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTamper(v)
		return nil
	case securityjournal.FieldSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSummary(v)
		return nil
	case securityjournal.FieldPairSubjectCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPairSubjectCode(v)
		return nil
	case securityjournal.FieldPairSecurityAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPairSecurityAccountID(v)
		return nil
	case securityjournal.FieldLastBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBalance(v)
		return nil
	case securityjournal.FieldStlTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlTime(v)
		return nil
	case securityjournal.FieldFxRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFxRate(v)
		return nil
	case securityjournal.FieldStlCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlCurrency(v)
		return nil
	case securityjournal.FieldStlAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlAmount(v)
		return nil
	case securityjournal.FieldStlMarginLv:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlMarginLv(v)
		return nil
	case securityjournal.FieldIsSettlement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSettlement(v)
		return nil
	case securityjournal.FieldActualStlTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStlTime(v)
		return nil
	case securityjournal.FieldTransNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransNo(v)
		return nil
	case securityjournal.FieldTransTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransTime(v)
		return nil
	case securityjournal.FieldAccountingNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingNo(v)
		return nil
	case securityjournal.FieldAccountingTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountingTime(v)
		return nil
	case securityjournal.FieldAccountedPositionQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountedPositionQty(v)
		return nil
	case securityjournal.FieldCdDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdDirection(v)
		return nil
	case securityjournal.FieldApplyFields:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyFields(v)
		return nil
	case securityjournal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case securityjournal.FieldRefTransNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefTransNo(v)
		return nil
	case securityjournal.FieldIsDayBooking:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDayBooking(v)
		return nil
	case securityjournal.FieldIsEffectFund:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEffectFund(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityJournal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityJournalMutation) AddedFields() []string {
	var fields []string
	if m.addsecurity_account_id != nil {
		fields = append(fields, securityjournal.FieldSecurityAccountID)
	}
	if m.addaccount_id != nil {
		fields = append(fields, securityjournal.FieldAccountID)
	}
	if m.addorg_id != nil {
		fields = append(fields, securityjournal.FieldOrgID)
	}
	if m.addrecord_method_id != nil {
		fields = append(fields, securityjournal.FieldRecordMethodID)
	}
	if m.addproject_id != nil {
		fields = append(fields, securityjournal.FieldProjectID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, securityjournal.FieldProductID)
	}
	if m.addmaterial_id != nil {
		fields = append(fields, securityjournal.FieldMaterialID)
	}
	if m.addmultiplier != nil {
		fields = append(fields, securityjournal.FieldMultiplier)
	}
	if m.addposition_type != nil {
		fields = append(fields, securityjournal.FieldPositionType)
	}
	if m.addqty != nil {
		fields = append(fields, securityjournal.FieldQty)
	}
	if m.addprice != nil {
		fields = append(fields, securityjournal.FieldPrice)
	}
	if m.addamount != nil {
		fields = append(fields, securityjournal.FieldAmount)
	}
	if m.addcost != nil {
		fields = append(fields, securityjournal.FieldCost)
	}
	if m.addtotal != nil {
		fields = append(fields, securityjournal.FieldTotal)
	}
	if m.addcommission != nil {
		fields = append(fields, securityjournal.FieldCommission)
	}
	if m.addfee != nil {
		fields = append(fields, securityjournal.FieldFee)
	}
	if m.addfee_other != nil {
		fields = append(fields, securityjournal.FieldFeeOther)
	}
	if m.addcount != nil {
		fields = append(fields, securityjournal.FieldCount)
	}
	if m.adddirection != nil {
		fields = append(fields, securityjournal.FieldDirection)
	}
	if m.addpair_security_account_id != nil {
		fields = append(fields, securityjournal.FieldPairSecurityAccountID)
	}
	if m.addlast_balance != nil {
		fields = append(fields, securityjournal.FieldLastBalance)
	}
	if m.addfx_rate != nil {
		fields = append(fields, securityjournal.FieldFxRate)
	}
	if m.addstl_amount != nil {
		fields = append(fields, securityjournal.FieldStlAmount)
	}
	if m.addstl_margin_lv != nil {
		fields = append(fields, securityjournal.FieldStlMarginLv)
	}
	if m.addaccounted_position_qty != nil {
		fields = append(fields, securityjournal.FieldAccountedPositionQty)
	}
	if m.addcd_direction != nil {
		fields = append(fields, securityjournal.FieldCdDirection)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityJournalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case securityjournal.FieldSecurityAccountID:
		return m.AddedSecurityAccountID()
	case securityjournal.FieldAccountID:
		return m.AddedAccountID()
	case securityjournal.FieldOrgID:
		return m.AddedOrgID()
	case securityjournal.FieldRecordMethodID:
		return m.AddedRecordMethodID()
	case securityjournal.FieldProjectID:
		return m.AddedProjectID()
	case securityjournal.FieldProductID:
		return m.AddedProductID()
	case securityjournal.FieldMaterialID:
		return m.AddedMaterialID()
	case securityjournal.FieldMultiplier:
		return m.AddedMultiplier()
	case securityjournal.FieldPositionType:
		return m.AddedPositionType()
	case securityjournal.FieldQty:
		return m.AddedQty()
	case securityjournal.FieldPrice:
		return m.AddedPrice()
	case securityjournal.FieldAmount:
		return m.AddedAmount()
	case securityjournal.FieldCost:
		return m.AddedCost()
	case securityjournal.FieldTotal:
		return m.AddedTotal()
	case securityjournal.FieldCommission:
		return m.AddedCommission()
	case securityjournal.FieldFee:
		return m.AddedFee()
	case securityjournal.FieldFeeOther:
		return m.AddedFeeOther()
	case securityjournal.FieldCount:
		return m.AddedCount()
	case securityjournal.FieldDirection:
		return m.AddedDirection()
	case securityjournal.FieldPairSecurityAccountID:
		return m.AddedPairSecurityAccountID()
	case securityjournal.FieldLastBalance:
		return m.AddedLastBalance()
	case securityjournal.FieldFxRate:
		return m.AddedFxRate()
	case securityjournal.FieldStlAmount:
		return m.AddedStlAmount()
	case securityjournal.FieldStlMarginLv:
		return m.AddedStlMarginLv()
	case securityjournal.FieldAccountedPositionQty:
		return m.AddedAccountedPositionQty()
	case securityjournal.FieldCdDirection:
		return m.AddedCdDirection()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityJournalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case securityjournal.FieldSecurityAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecurityAccountID(v)
		return nil
	case securityjournal.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case securityjournal.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgID(v)
		return nil
	case securityjournal.FieldRecordMethodID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRecordMethodID(v)
		return nil
	case securityjournal.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	case securityjournal.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case securityjournal.FieldMaterialID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialID(v)
		return nil
	case securityjournal.FieldMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMultiplier(v)
		return nil
	case securityjournal.FieldPositionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionType(v)
		return nil
	case securityjournal.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	case securityjournal.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case securityjournal.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case securityjournal.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case securityjournal.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case securityjournal.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommission(v)
		return nil
	case securityjournal.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case securityjournal.FieldFeeOther:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFeeOther(v)
		return nil
	case securityjournal.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case securityjournal.FieldDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDirection(v)
		return nil
	case securityjournal.FieldPairSecurityAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPairSecurityAccountID(v)
		return nil
	case securityjournal.FieldLastBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastBalance(v)
		return nil
	case securityjournal.FieldFxRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFxRate(v)
		return nil
	case securityjournal.FieldStlAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlAmount(v)
		return nil
	case securityjournal.FieldStlMarginLv:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlMarginLv(v)
		return nil
	case securityjournal.FieldAccountedPositionQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountedPositionQty(v)
		return nil
	case securityjournal.FieldCdDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCdDirection(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityJournal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityJournalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securityjournal.FieldAccountID) {
		fields = append(fields, securityjournal.FieldAccountID)
	}
	if m.FieldCleared(securityjournal.FieldBizNo) {
		fields = append(fields, securityjournal.FieldBizNo)
	}
	if m.FieldCleared(securityjournal.FieldBizType) {
		fields = append(fields, securityjournal.FieldBizType)
	}
	if m.FieldCleared(securityjournal.FieldTradeCode) {
		fields = append(fields, securityjournal.FieldTradeCode)
	}
	if m.FieldCleared(securityjournal.FieldChangeType) {
		fields = append(fields, securityjournal.FieldChangeType)
	}
	if m.FieldCleared(securityjournal.FieldRecordMethodID) {
		fields = append(fields, securityjournal.FieldRecordMethodID)
	}
	if m.FieldCleared(securityjournal.FieldProjectID) {
		fields = append(fields, securityjournal.FieldProjectID)
	}
	if m.FieldCleared(securityjournal.FieldProductID) {
		fields = append(fields, securityjournal.FieldProductID)
	}
	if m.FieldCleared(securityjournal.FieldMaterialID) {
		fields = append(fields, securityjournal.FieldMaterialID)
	}
	if m.FieldCleared(securityjournal.FieldMaterialNo) {
		fields = append(fields, securityjournal.FieldMaterialNo)
	}
	if m.FieldCleared(securityjournal.FieldMaterialName) {
		fields = append(fields, securityjournal.FieldMaterialName)
	}
	if m.FieldCleared(securityjournal.FieldMultiplier) {
		fields = append(fields, securityjournal.FieldMultiplier)
	}
	if m.FieldCleared(securityjournal.FieldPositionType) {
		fields = append(fields, securityjournal.FieldPositionType)
	}
	if m.FieldCleared(securityjournal.FieldCurrency) {
		fields = append(fields, securityjournal.FieldCurrency)
	}
	if m.FieldCleared(securityjournal.FieldQty) {
		fields = append(fields, securityjournal.FieldQty)
	}
	if m.FieldCleared(securityjournal.FieldPrice) {
		fields = append(fields, securityjournal.FieldPrice)
	}
	if m.FieldCleared(securityjournal.FieldAmount) {
		fields = append(fields, securityjournal.FieldAmount)
	}
	if m.FieldCleared(securityjournal.FieldCost) {
		fields = append(fields, securityjournal.FieldCost)
	}
	if m.FieldCleared(securityjournal.FieldTotal) {
		fields = append(fields, securityjournal.FieldTotal)
	}
	if m.FieldCleared(securityjournal.FieldUnit) {
		fields = append(fields, securityjournal.FieldUnit)
	}
	if m.FieldCleared(securityjournal.FieldSpec) {
		fields = append(fields, securityjournal.FieldSpec)
	}
	if m.FieldCleared(securityjournal.FieldCommission) {
		fields = append(fields, securityjournal.FieldCommission)
	}
	if m.FieldCleared(securityjournal.FieldFee) {
		fields = append(fields, securityjournal.FieldFee)
	}
	if m.FieldCleared(securityjournal.FieldFeeOther) {
		fields = append(fields, securityjournal.FieldFeeOther)
	}
	if m.FieldCleared(securityjournal.FieldCount) {
		fields = append(fields, securityjournal.FieldCount)
	}
	if m.FieldCleared(securityjournal.FieldDirection) {
		fields = append(fields, securityjournal.FieldDirection)
	}
	if m.FieldCleared(securityjournal.FieldTamper) {
		fields = append(fields, securityjournal.FieldTamper)
	}
	if m.FieldCleared(securityjournal.FieldSummary) {
		fields = append(fields, securityjournal.FieldSummary)
	}
	if m.FieldCleared(securityjournal.FieldPairSubjectCode) {
		fields = append(fields, securityjournal.FieldPairSubjectCode)
	}
	if m.FieldCleared(securityjournal.FieldPairSecurityAccountID) {
		fields = append(fields, securityjournal.FieldPairSecurityAccountID)
	}
	if m.FieldCleared(securityjournal.FieldLastBalance) {
		fields = append(fields, securityjournal.FieldLastBalance)
	}
	if m.FieldCleared(securityjournal.FieldStlTime) {
		fields = append(fields, securityjournal.FieldStlTime)
	}
	if m.FieldCleared(securityjournal.FieldFxRate) {
		fields = append(fields, securityjournal.FieldFxRate)
	}
	if m.FieldCleared(securityjournal.FieldStlCurrency) {
		fields = append(fields, securityjournal.FieldStlCurrency)
	}
	if m.FieldCleared(securityjournal.FieldStlAmount) {
		fields = append(fields, securityjournal.FieldStlAmount)
	}
	if m.FieldCleared(securityjournal.FieldStlMarginLv) {
		fields = append(fields, securityjournal.FieldStlMarginLv)
	}
	if m.FieldCleared(securityjournal.FieldIsSettlement) {
		fields = append(fields, securityjournal.FieldIsSettlement)
	}
	if m.FieldCleared(securityjournal.FieldActualStlTime) {
		fields = append(fields, securityjournal.FieldActualStlTime)
	}
	if m.FieldCleared(securityjournal.FieldTransNo) {
		fields = append(fields, securityjournal.FieldTransNo)
	}
	if m.FieldCleared(securityjournal.FieldTransTime) {
		fields = append(fields, securityjournal.FieldTransTime)
	}
	if m.FieldCleared(securityjournal.FieldAccountingNo) {
		fields = append(fields, securityjournal.FieldAccountingNo)
	}
	if m.FieldCleared(securityjournal.FieldAccountingTime) {
		fields = append(fields, securityjournal.FieldAccountingTime)
	}
	if m.FieldCleared(securityjournal.FieldAccountedPositionQty) {
		fields = append(fields, securityjournal.FieldAccountedPositionQty)
	}
	if m.FieldCleared(securityjournal.FieldCdDirection) {
		fields = append(fields, securityjournal.FieldCdDirection)
	}
	if m.FieldCleared(securityjournal.FieldApplyFields) {
		fields = append(fields, securityjournal.FieldApplyFields)
	}
	if m.FieldCleared(securityjournal.FieldCreatedAt) {
		fields = append(fields, securityjournal.FieldCreatedAt)
	}
	if m.FieldCleared(securityjournal.FieldRefTransNo) {
		fields = append(fields, securityjournal.FieldRefTransNo)
	}
	if m.FieldCleared(securityjournal.FieldIsDayBooking) {
		fields = append(fields, securityjournal.FieldIsDayBooking)
	}
	if m.FieldCleared(securityjournal.FieldIsEffectFund) {
		fields = append(fields, securityjournal.FieldIsEffectFund)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityJournalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityJournalMutation) ClearField(name string) error {
	switch name {
	case securityjournal.FieldAccountID:
		m.ClearAccountID()
		return nil
	case securityjournal.FieldBizNo:
		m.ClearBizNo()
		return nil
	case securityjournal.FieldBizType:
		m.ClearBizType()
		return nil
	case securityjournal.FieldTradeCode:
		m.ClearTradeCode()
		return nil
	case securityjournal.FieldChangeType:
		m.ClearChangeType()
		return nil
	case securityjournal.FieldRecordMethodID:
		m.ClearRecordMethodID()
		return nil
	case securityjournal.FieldProjectID:
		m.ClearProjectID()
		return nil
	case securityjournal.FieldProductID:
		m.ClearProductID()
		return nil
	case securityjournal.FieldMaterialID:
		m.ClearMaterialID()
		return nil
	case securityjournal.FieldMaterialNo:
		m.ClearMaterialNo()
		return nil
	case securityjournal.FieldMaterialName:
		m.ClearMaterialName()
		return nil
	case securityjournal.FieldMultiplier:
		m.ClearMultiplier()
		return nil
	case securityjournal.FieldPositionType:
		m.ClearPositionType()
		return nil
	case securityjournal.FieldCurrency:
		m.ClearCurrency()
		return nil
	case securityjournal.FieldQty:
		m.ClearQty()
		return nil
	case securityjournal.FieldPrice:
		m.ClearPrice()
		return nil
	case securityjournal.FieldAmount:
		m.ClearAmount()
		return nil
	case securityjournal.FieldCost:
		m.ClearCost()
		return nil
	case securityjournal.FieldTotal:
		m.ClearTotal()
		return nil
	case securityjournal.FieldUnit:
		m.ClearUnit()
		return nil
	case securityjournal.FieldSpec:
		m.ClearSpec()
		return nil
	case securityjournal.FieldCommission:
		m.ClearCommission()
		return nil
	case securityjournal.FieldFee:
		m.ClearFee()
		return nil
	case securityjournal.FieldFeeOther:
		m.ClearFeeOther()
		return nil
	case securityjournal.FieldCount:
		m.ClearCount()
		return nil
	case securityjournal.FieldDirection:
		m.ClearDirection()
		return nil
	case securityjournal.FieldTamper:
		m.ClearTamper()
		return nil
	case securityjournal.FieldSummary:
		m.ClearSummary()
		return nil
	case securityjournal.FieldPairSubjectCode:
		m.ClearPairSubjectCode()
		return nil
	case securityjournal.FieldPairSecurityAccountID:
		m.ClearPairSecurityAccountID()
		return nil
	case securityjournal.FieldLastBalance:
		m.ClearLastBalance()
		return nil
	case securityjournal.FieldStlTime:
		m.ClearStlTime()
		return nil
	case securityjournal.FieldFxRate:
		m.ClearFxRate()
		return nil
	case securityjournal.FieldStlCurrency:
		m.ClearStlCurrency()
		return nil
	case securityjournal.FieldStlAmount:
		m.ClearStlAmount()
		return nil
	case securityjournal.FieldStlMarginLv:
		m.ClearStlMarginLv()
		return nil
	case securityjournal.FieldIsSettlement:
		m.ClearIsSettlement()
		return nil
	case securityjournal.FieldActualStlTime:
		m.ClearActualStlTime()
		return nil
	case securityjournal.FieldTransNo:
		m.ClearTransNo()
		return nil
	case securityjournal.FieldTransTime:
		m.ClearTransTime()
		return nil
	case securityjournal.FieldAccountingNo:
		m.ClearAccountingNo()
		return nil
	case securityjournal.FieldAccountingTime:
		m.ClearAccountingTime()
		return nil
	case securityjournal.FieldAccountedPositionQty:
		m.ClearAccountedPositionQty()
		return nil
	case securityjournal.FieldCdDirection:
		m.ClearCdDirection()
		return nil
	case securityjournal.FieldApplyFields:
		m.ClearApplyFields()
		return nil
	case securityjournal.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case securityjournal.FieldRefTransNo:
		m.ClearRefTransNo()
		return nil
	case securityjournal.FieldIsDayBooking:
		m.ClearIsDayBooking()
		return nil
	case securityjournal.FieldIsEffectFund:
		m.ClearIsEffectFund()
		return nil
	}
	return fmt.Errorf("unknown SecurityJournal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityJournalMutation) ResetField(name string) error {
	switch name {
	case securityjournal.FieldSecurityAccountID:
		m.ResetSecurityAccountID()
		return nil
	case securityjournal.FieldAccountID:
		m.ResetAccountID()
		return nil
	case securityjournal.FieldBizNo:
		m.ResetBizNo()
		return nil
	case securityjournal.FieldBizType:
		m.ResetBizType()
		return nil
	case securityjournal.FieldOrgID:
		m.ResetOrgID()
		return nil
	case securityjournal.FieldTradeCode:
		m.ResetTradeCode()
		return nil
	case securityjournal.FieldChangeType:
		m.ResetChangeType()
		return nil
	case securityjournal.FieldRecordMethodID:
		m.ResetRecordMethodID()
		return nil
	case securityjournal.FieldProjectID:
		m.ResetProjectID()
		return nil
	case securityjournal.FieldProductID:
		m.ResetProductID()
		return nil
	case securityjournal.FieldMaterialID:
		m.ResetMaterialID()
		return nil
	case securityjournal.FieldMaterialNo:
		m.ResetMaterialNo()
		return nil
	case securityjournal.FieldMaterialName:
		m.ResetMaterialName()
		return nil
	case securityjournal.FieldMultiplier:
		m.ResetMultiplier()
		return nil
	case securityjournal.FieldPositionType:
		m.ResetPositionType()
		return nil
	case securityjournal.FieldCurrency:
		m.ResetCurrency()
		return nil
	case securityjournal.FieldQty:
		m.ResetQty()
		return nil
	case securityjournal.FieldPrice:
		m.ResetPrice()
		return nil
	case securityjournal.FieldAmount:
		m.ResetAmount()
		return nil
	case securityjournal.FieldCost:
		m.ResetCost()
		return nil
	case securityjournal.FieldTotal:
		m.ResetTotal()
		return nil
	case securityjournal.FieldUnit:
		m.ResetUnit()
		return nil
	case securityjournal.FieldSpec:
		m.ResetSpec()
		return nil
	case securityjournal.FieldCommission:
		m.ResetCommission()
		return nil
	case securityjournal.FieldFee:
		m.ResetFee()
		return nil
	case securityjournal.FieldFeeOther:
		m.ResetFeeOther()
		return nil
	case securityjournal.FieldCount:
		m.ResetCount()
		return nil
	case securityjournal.FieldDirection:
		m.ResetDirection()
		return nil
	case securityjournal.FieldTamper:
		m.ResetTamper()
		return nil
	case securityjournal.FieldSummary:
		m.ResetSummary()
		return nil
	case securityjournal.FieldPairSubjectCode:
		m.ResetPairSubjectCode()
		return nil
	case securityjournal.FieldPairSecurityAccountID:
		m.ResetPairSecurityAccountID()
		return nil
	case securityjournal.FieldLastBalance:
		m.ResetLastBalance()
		return nil
	case securityjournal.FieldStlTime:
		m.ResetStlTime()
		return nil
	case securityjournal.FieldFxRate:
		m.ResetFxRate()
		return nil
	case securityjournal.FieldStlCurrency:
		m.ResetStlCurrency()
		return nil
	case securityjournal.FieldStlAmount:
		m.ResetStlAmount()
		return nil
	case securityjournal.FieldStlMarginLv:
		m.ResetStlMarginLv()
		return nil
	case securityjournal.FieldIsSettlement:
		m.ResetIsSettlement()
		return nil
	case securityjournal.FieldActualStlTime:
		m.ResetActualStlTime()
		return nil
	case securityjournal.FieldTransNo:
		m.ResetTransNo()
		return nil
	case securityjournal.FieldTransTime:
		m.ResetTransTime()
		return nil
	case securityjournal.FieldAccountingNo:
		m.ResetAccountingNo()
		return nil
	case securityjournal.FieldAccountingTime:
		m.ResetAccountingTime()
		return nil
	case securityjournal.FieldAccountedPositionQty:
		m.ResetAccountedPositionQty()
		return nil
	case securityjournal.FieldCdDirection:
		m.ResetCdDirection()
		return nil
	case securityjournal.FieldApplyFields:
		m.ResetApplyFields()
		return nil
	case securityjournal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case securityjournal.FieldRefTransNo:
		m.ResetRefTransNo()
		return nil
	case securityjournal.FieldIsDayBooking:
		m.ResetIsDayBooking()
		return nil
	case securityjournal.FieldIsEffectFund:
		m.ResetIsEffectFund()
		return nil
	}
	return fmt.Errorf("unknown SecurityJournal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityJournalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityJournalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityJournalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityJournalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityJournalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityJournalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityJournalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SecurityJournal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityJournalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SecurityJournal edge %s", name)
}

// SecurityPositionMutation represents an operation that mutates the SecurityPosition nodes in the graph.
type SecurityPositionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	parent_id              *int
	addparent_id           *int
	account_id             *int
	addaccount_id          *int
	security_account_id    *int
	addsecurity_account_id *int
	position_type          *int
	addposition_type       *int
	cd_direction           *int
	addcd_direction        *int
	project_id             *int
	addproject_id          *int
	product_id             *int
	addproduct_id          *int
	material_id            *int
	addmaterial_id         *int
	material_no            *string
	multiplier             *float64
	addmultiplier          *float64
	balance                *float64
	addbalance             *float64
	available              *float64
	addavailable           *float64
	freeze                 *float64
	addfreeze              *float64
	afloat                 *float64
	addafloat              *float64
	unit                   *string
	spec                   *string
	currency               *string
	price                  *float64
	addprice               *float64
	amount                 *float64
	addamount              *float64
	cost_amount            *float64
	addcost_amount         *float64
	cost                   *float64
	addcost                *float64
	fx_rate                *float64
	addfx_rate             *float64
	stl_currency           *string
	stl_amount             *float64
	addstl_amount          *float64
	stl_cost               *float64
	addstl_cost            *float64
	stl_margin             *float64
	addstl_margin          *float64
	stl_cost_amount        *float64
	addstl_cost_amount     *float64
	stl_margin_lv          *float64
	addstl_margin_lv       *float64
	stl_val_price          *float64
	addstl_val_price       *float64
	invalid_at             *time.Time
	created_at             *time.Time
	unique_tag             *string
	org_id                 *int
	addorg_id              *int
	clearedFields          map[string]struct{}
	done                   bool
	oldValue               func(context.Context) (*SecurityPosition, error)
	predicates             []predicate.SecurityPosition
}

var _ ent.Mutation = (*SecurityPositionMutation)(nil)

// securitypositionOption allows management of the mutation configuration using functional options.
type securitypositionOption func(*SecurityPositionMutation)

// newSecurityPositionMutation creates new mutation for the SecurityPosition entity.
func newSecurityPositionMutation(c config, op Op, opts ...securitypositionOption) *SecurityPositionMutation {
	m := &SecurityPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeSecurityPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSecurityPositionID sets the ID field of the mutation.
func withSecurityPositionID(id int) securitypositionOption {
	return func(m *SecurityPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *SecurityPosition
		)
		m.oldValue = func(ctx context.Context) (*SecurityPosition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SecurityPosition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSecurityPosition sets the old SecurityPosition of the mutation.
func withSecurityPosition(node *SecurityPosition) securitypositionOption {
	return func(m *SecurityPositionMutation) {
		m.oldValue = func(context.Context) (*SecurityPosition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SecurityPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SecurityPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SecurityPosition entities.
func (m *SecurityPositionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SecurityPositionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SecurityPositionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SecurityPosition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent_id" field.
func (m *SecurityPositionMutation) SetParentID(i int) {
	m.parent_id = &i
	m.addparent_id = nil
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *SecurityPositionMutation) ParentID() (r int, exists bool) {
	v := m.parent_id
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// AddParentID adds i to the "parent_id" field.
func (m *SecurityPositionMutation) AddParentID(i int) {
	if m.addparent_id != nil {
		*m.addparent_id += i
	} else {
		m.addparent_id = &i
	}
}

// AddedParentID returns the value that was added to the "parent_id" field in this mutation.
func (m *SecurityPositionMutation) AddedParentID() (r int, exists bool) {
	v := m.addparent_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *SecurityPositionMutation) ResetParentID() {
	m.parent_id = nil
	m.addparent_id = nil
}

// SetAccountID sets the "account_id" field.
func (m *SecurityPositionMutation) SetAccountID(i int) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *SecurityPositionMutation) AccountID() (r int, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *SecurityPositionMutation) AddAccountID(i int) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *SecurityPositionMutation) AddedAccountID() (r int, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccountID clears the value of the "account_id" field.
func (m *SecurityPositionMutation) ClearAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
	m.clearedFields[securityposition.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *SecurityPositionMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *SecurityPositionMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
	delete(m.clearedFields, securityposition.FieldAccountID)
}

// SetSecurityAccountID sets the "security_account_id" field.
func (m *SecurityPositionMutation) SetSecurityAccountID(i int) {
	m.security_account_id = &i
	m.addsecurity_account_id = nil
}

// SecurityAccountID returns the value of the "security_account_id" field in the mutation.
func (m *SecurityPositionMutation) SecurityAccountID() (r int, exists bool) {
	v := m.security_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSecurityAccountID returns the old "security_account_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldSecurityAccountID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecurityAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecurityAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecurityAccountID: %w", err)
	}
	return oldValue.SecurityAccountID, nil
}

// AddSecurityAccountID adds i to the "security_account_id" field.
func (m *SecurityPositionMutation) AddSecurityAccountID(i int) {
	if m.addsecurity_account_id != nil {
		*m.addsecurity_account_id += i
	} else {
		m.addsecurity_account_id = &i
	}
}

// AddedSecurityAccountID returns the value that was added to the "security_account_id" field in this mutation.
func (m *SecurityPositionMutation) AddedSecurityAccountID() (r int, exists bool) {
	v := m.addsecurity_account_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecurityAccountID resets all changes to the "security_account_id" field.
func (m *SecurityPositionMutation) ResetSecurityAccountID() {
	m.security_account_id = nil
	m.addsecurity_account_id = nil
}

// SetPositionType sets the "position_type" field.
func (m *SecurityPositionMutation) SetPositionType(i int) {
	m.position_type = &i
	m.addposition_type = nil
}

// PositionType returns the value of the "position_type" field in the mutation.
func (m *SecurityPositionMutation) PositionType() (r int, exists bool) {
	v := m.position_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionType returns the old "position_type" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldPositionType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionType: %w", err)
	}
	return oldValue.PositionType, nil
}

// AddPositionType adds i to the "position_type" field.
func (m *SecurityPositionMutation) AddPositionType(i int) {
	if m.addposition_type != nil {
		*m.addposition_type += i
	} else {
		m.addposition_type = &i
	}
}

// AddedPositionType returns the value that was added to the "position_type" field in this mutation.
func (m *SecurityPositionMutation) AddedPositionType() (r int, exists bool) {
	v := m.addposition_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearPositionType clears the value of the "position_type" field.
func (m *SecurityPositionMutation) ClearPositionType() {
	m.position_type = nil
	m.addposition_type = nil
	m.clearedFields[securityposition.FieldPositionType] = struct{}{}
}

// PositionTypeCleared returns if the "position_type" field was cleared in this mutation.
func (m *SecurityPositionMutation) PositionTypeCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldPositionType]
	return ok
}

// ResetPositionType resets all changes to the "position_type" field.
func (m *SecurityPositionMutation) ResetPositionType() {
	m.position_type = nil
	m.addposition_type = nil
	delete(m.clearedFields, securityposition.FieldPositionType)
}

// SetCdDirection sets the "cd_direction" field.
func (m *SecurityPositionMutation) SetCdDirection(i int) {
	m.cd_direction = &i
	m.addcd_direction = nil
}

// CdDirection returns the value of the "cd_direction" field in the mutation.
func (m *SecurityPositionMutation) CdDirection() (r int, exists bool) {
	v := m.cd_direction
	if v == nil {
		return
	}
	return *v, true
}

// OldCdDirection returns the old "cd_direction" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldCdDirection(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCdDirection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCdDirection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCdDirection: %w", err)
	}
	return oldValue.CdDirection, nil
}

// AddCdDirection adds i to the "cd_direction" field.
func (m *SecurityPositionMutation) AddCdDirection(i int) {
	if m.addcd_direction != nil {
		*m.addcd_direction += i
	} else {
		m.addcd_direction = &i
	}
}

// AddedCdDirection returns the value that was added to the "cd_direction" field in this mutation.
func (m *SecurityPositionMutation) AddedCdDirection() (r int, exists bool) {
	v := m.addcd_direction
	if v == nil {
		return
	}
	return *v, true
}

// ClearCdDirection clears the value of the "cd_direction" field.
func (m *SecurityPositionMutation) ClearCdDirection() {
	m.cd_direction = nil
	m.addcd_direction = nil
	m.clearedFields[securityposition.FieldCdDirection] = struct{}{}
}

// CdDirectionCleared returns if the "cd_direction" field was cleared in this mutation.
func (m *SecurityPositionMutation) CdDirectionCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldCdDirection]
	return ok
}

// ResetCdDirection resets all changes to the "cd_direction" field.
func (m *SecurityPositionMutation) ResetCdDirection() {
	m.cd_direction = nil
	m.addcd_direction = nil
	delete(m.clearedFields, securityposition.FieldCdDirection)
}

// SetProjectID sets the "project_id" field.
func (m *SecurityPositionMutation) SetProjectID(i int) {
	m.project_id = &i
	m.addproject_id = nil
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *SecurityPositionMutation) ProjectID() (r int, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// AddProjectID adds i to the "project_id" field.
func (m *SecurityPositionMutation) AddProjectID(i int) {
	if m.addproject_id != nil {
		*m.addproject_id += i
	} else {
		m.addproject_id = &i
	}
}

// AddedProjectID returns the value that was added to the "project_id" field in this mutation.
func (m *SecurityPositionMutation) AddedProjectID() (r int, exists bool) {
	v := m.addproject_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProjectID clears the value of the "project_id" field.
func (m *SecurityPositionMutation) ClearProjectID() {
	m.project_id = nil
	m.addproject_id = nil
	m.clearedFields[securityposition.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *SecurityPositionMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *SecurityPositionMutation) ResetProjectID() {
	m.project_id = nil
	m.addproject_id = nil
	delete(m.clearedFields, securityposition.FieldProjectID)
}

// SetProductID sets the "product_id" field.
func (m *SecurityPositionMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *SecurityPositionMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *SecurityPositionMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *SecurityPositionMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *SecurityPositionMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetMaterialID sets the "material_id" field.
func (m *SecurityPositionMutation) SetMaterialID(i int) {
	m.material_id = &i
	m.addmaterial_id = nil
}

// MaterialID returns the value of the "material_id" field in the mutation.
func (m *SecurityPositionMutation) MaterialID() (r int, exists bool) {
	v := m.material_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialID returns the old "material_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldMaterialID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialID: %w", err)
	}
	return oldValue.MaterialID, nil
}

// AddMaterialID adds i to the "material_id" field.
func (m *SecurityPositionMutation) AddMaterialID(i int) {
	if m.addmaterial_id != nil {
		*m.addmaterial_id += i
	} else {
		m.addmaterial_id = &i
	}
}

// AddedMaterialID returns the value that was added to the "material_id" field in this mutation.
func (m *SecurityPositionMutation) AddedMaterialID() (r int, exists bool) {
	v := m.addmaterial_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaterialID clears the value of the "material_id" field.
func (m *SecurityPositionMutation) ClearMaterialID() {
	m.material_id = nil
	m.addmaterial_id = nil
	m.clearedFields[securityposition.FieldMaterialID] = struct{}{}
}

// MaterialIDCleared returns if the "material_id" field was cleared in this mutation.
func (m *SecurityPositionMutation) MaterialIDCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldMaterialID]
	return ok
}

// ResetMaterialID resets all changes to the "material_id" field.
func (m *SecurityPositionMutation) ResetMaterialID() {
	m.material_id = nil
	m.addmaterial_id = nil
	delete(m.clearedFields, securityposition.FieldMaterialID)
}

// SetMaterialNo sets the "material_no" field.
func (m *SecurityPositionMutation) SetMaterialNo(s string) {
	m.material_no = &s
}

// MaterialNo returns the value of the "material_no" field in the mutation.
func (m *SecurityPositionMutation) MaterialNo() (r string, exists bool) {
	v := m.material_no
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialNo returns the old "material_no" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldMaterialNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialNo: %w", err)
	}
	return oldValue.MaterialNo, nil
}

// ClearMaterialNo clears the value of the "material_no" field.
func (m *SecurityPositionMutation) ClearMaterialNo() {
	m.material_no = nil
	m.clearedFields[securityposition.FieldMaterialNo] = struct{}{}
}

// MaterialNoCleared returns if the "material_no" field was cleared in this mutation.
func (m *SecurityPositionMutation) MaterialNoCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldMaterialNo]
	return ok
}

// ResetMaterialNo resets all changes to the "material_no" field.
func (m *SecurityPositionMutation) ResetMaterialNo() {
	m.material_no = nil
	delete(m.clearedFields, securityposition.FieldMaterialNo)
}

// SetMultiplier sets the "multiplier" field.
func (m *SecurityPositionMutation) SetMultiplier(f float64) {
	m.multiplier = &f
	m.addmultiplier = nil
}

// Multiplier returns the value of the "multiplier" field in the mutation.
func (m *SecurityPositionMutation) Multiplier() (r float64, exists bool) {
	v := m.multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiplier returns the old "multiplier" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldMultiplier(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiplier: %w", err)
	}
	return oldValue.Multiplier, nil
}

// AddMultiplier adds f to the "multiplier" field.
func (m *SecurityPositionMutation) AddMultiplier(f float64) {
	if m.addmultiplier != nil {
		*m.addmultiplier += f
	} else {
		m.addmultiplier = &f
	}
}

// AddedMultiplier returns the value that was added to the "multiplier" field in this mutation.
func (m *SecurityPositionMutation) AddedMultiplier() (r float64, exists bool) {
	v := m.addmultiplier
	if v == nil {
		return
	}
	return *v, true
}

// ClearMultiplier clears the value of the "multiplier" field.
func (m *SecurityPositionMutation) ClearMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
	m.clearedFields[securityposition.FieldMultiplier] = struct{}{}
}

// MultiplierCleared returns if the "multiplier" field was cleared in this mutation.
func (m *SecurityPositionMutation) MultiplierCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldMultiplier]
	return ok
}

// ResetMultiplier resets all changes to the "multiplier" field.
func (m *SecurityPositionMutation) ResetMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
	delete(m.clearedFields, securityposition.FieldMultiplier)
}

// SetBalance sets the "balance" field.
func (m *SecurityPositionMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *SecurityPositionMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *SecurityPositionMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *SecurityPositionMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "balance" field.
func (m *SecurityPositionMutation) ClearBalance() {
	m.balance = nil
	m.addbalance = nil
	m.clearedFields[securityposition.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "balance" field was cleared in this mutation.
func (m *SecurityPositionMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "balance" field.
func (m *SecurityPositionMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
	delete(m.clearedFields, securityposition.FieldBalance)
}

// SetAvailable sets the "available" field.
func (m *SecurityPositionMutation) SetAvailable(f float64) {
	m.available = &f
	m.addavailable = nil
}

// Available returns the value of the "available" field in the mutation.
func (m *SecurityPositionMutation) Available() (r float64, exists bool) {
	v := m.available
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailable returns the old "available" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldAvailable(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailable: %w", err)
	}
	return oldValue.Available, nil
}

// AddAvailable adds f to the "available" field.
func (m *SecurityPositionMutation) AddAvailable(f float64) {
	if m.addavailable != nil {
		*m.addavailable += f
	} else {
		m.addavailable = &f
	}
}

// AddedAvailable returns the value that was added to the "available" field in this mutation.
func (m *SecurityPositionMutation) AddedAvailable() (r float64, exists bool) {
	v := m.addavailable
	if v == nil {
		return
	}
	return *v, true
}

// ClearAvailable clears the value of the "available" field.
func (m *SecurityPositionMutation) ClearAvailable() {
	m.available = nil
	m.addavailable = nil
	m.clearedFields[securityposition.FieldAvailable] = struct{}{}
}

// AvailableCleared returns if the "available" field was cleared in this mutation.
func (m *SecurityPositionMutation) AvailableCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldAvailable]
	return ok
}

// ResetAvailable resets all changes to the "available" field.
func (m *SecurityPositionMutation) ResetAvailable() {
	m.available = nil
	m.addavailable = nil
	delete(m.clearedFields, securityposition.FieldAvailable)
}

// SetFreeze sets the "freeze" field.
func (m *SecurityPositionMutation) SetFreeze(f float64) {
	m.freeze = &f
	m.addfreeze = nil
}

// Freeze returns the value of the "freeze" field in the mutation.
func (m *SecurityPositionMutation) Freeze() (r float64, exists bool) {
	v := m.freeze
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeze returns the old "freeze" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldFreeze(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeze is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeze requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeze: %w", err)
	}
	return oldValue.Freeze, nil
}

// AddFreeze adds f to the "freeze" field.
func (m *SecurityPositionMutation) AddFreeze(f float64) {
	if m.addfreeze != nil {
		*m.addfreeze += f
	} else {
		m.addfreeze = &f
	}
}

// AddedFreeze returns the value that was added to the "freeze" field in this mutation.
func (m *SecurityPositionMutation) AddedFreeze() (r float64, exists bool) {
	v := m.addfreeze
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreeze clears the value of the "freeze" field.
func (m *SecurityPositionMutation) ClearFreeze() {
	m.freeze = nil
	m.addfreeze = nil
	m.clearedFields[securityposition.FieldFreeze] = struct{}{}
}

// FreezeCleared returns if the "freeze" field was cleared in this mutation.
func (m *SecurityPositionMutation) FreezeCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldFreeze]
	return ok
}

// ResetFreeze resets all changes to the "freeze" field.
func (m *SecurityPositionMutation) ResetFreeze() {
	m.freeze = nil
	m.addfreeze = nil
	delete(m.clearedFields, securityposition.FieldFreeze)
}

// SetAfloat sets the "afloat" field.
func (m *SecurityPositionMutation) SetAfloat(f float64) {
	m.afloat = &f
	m.addafloat = nil
}

// Afloat returns the value of the "afloat" field in the mutation.
func (m *SecurityPositionMutation) Afloat() (r float64, exists bool) {
	v := m.afloat
	if v == nil {
		return
	}
	return *v, true
}

// OldAfloat returns the old "afloat" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldAfloat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfloat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfloat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfloat: %w", err)
	}
	return oldValue.Afloat, nil
}

// AddAfloat adds f to the "afloat" field.
func (m *SecurityPositionMutation) AddAfloat(f float64) {
	if m.addafloat != nil {
		*m.addafloat += f
	} else {
		m.addafloat = &f
	}
}

// AddedAfloat returns the value that was added to the "afloat" field in this mutation.
func (m *SecurityPositionMutation) AddedAfloat() (r float64, exists bool) {
	v := m.addafloat
	if v == nil {
		return
	}
	return *v, true
}

// ClearAfloat clears the value of the "afloat" field.
func (m *SecurityPositionMutation) ClearAfloat() {
	m.afloat = nil
	m.addafloat = nil
	m.clearedFields[securityposition.FieldAfloat] = struct{}{}
}

// AfloatCleared returns if the "afloat" field was cleared in this mutation.
func (m *SecurityPositionMutation) AfloatCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldAfloat]
	return ok
}

// ResetAfloat resets all changes to the "afloat" field.
func (m *SecurityPositionMutation) ResetAfloat() {
	m.afloat = nil
	m.addafloat = nil
	delete(m.clearedFields, securityposition.FieldAfloat)
}

// SetUnit sets the "unit" field.
func (m *SecurityPositionMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SecurityPositionMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldUnit(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ClearUnit clears the value of the "unit" field.
func (m *SecurityPositionMutation) ClearUnit() {
	m.unit = nil
	m.clearedFields[securityposition.FieldUnit] = struct{}{}
}

// UnitCleared returns if the "unit" field was cleared in this mutation.
func (m *SecurityPositionMutation) UnitCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldUnit]
	return ok
}

// ResetUnit resets all changes to the "unit" field.
func (m *SecurityPositionMutation) ResetUnit() {
	m.unit = nil
	delete(m.clearedFields, securityposition.FieldUnit)
}

// SetSpec sets the "spec" field.
func (m *SecurityPositionMutation) SetSpec(s string) {
	m.spec = &s
}

// Spec returns the value of the "spec" field in the mutation.
func (m *SecurityPositionMutation) Spec() (r string, exists bool) {
	v := m.spec
	if v == nil {
		return
	}
	return *v, true
}

// OldSpec returns the old "spec" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldSpec(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpec is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpec requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpec: %w", err)
	}
	return oldValue.Spec, nil
}

// ClearSpec clears the value of the "spec" field.
func (m *SecurityPositionMutation) ClearSpec() {
	m.spec = nil
	m.clearedFields[securityposition.FieldSpec] = struct{}{}
}

// SpecCleared returns if the "spec" field was cleared in this mutation.
func (m *SecurityPositionMutation) SpecCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldSpec]
	return ok
}

// ResetSpec resets all changes to the "spec" field.
func (m *SecurityPositionMutation) ResetSpec() {
	m.spec = nil
	delete(m.clearedFields, securityposition.FieldSpec)
}

// SetCurrency sets the "currency" field.
func (m *SecurityPositionMutation) SetCurrency(s string) {
	m.currency = &s
}

// Currency returns the value of the "currency" field in the mutation.
func (m *SecurityPositionMutation) Currency() (r string, exists bool) {
	v := m.currency
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrency returns the old "currency" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrency: %w", err)
	}
	return oldValue.Currency, nil
}

// ClearCurrency clears the value of the "currency" field.
func (m *SecurityPositionMutation) ClearCurrency() {
	m.currency = nil
	m.clearedFields[securityposition.FieldCurrency] = struct{}{}
}

// CurrencyCleared returns if the "currency" field was cleared in this mutation.
func (m *SecurityPositionMutation) CurrencyCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldCurrency]
	return ok
}

// ResetCurrency resets all changes to the "currency" field.
func (m *SecurityPositionMutation) ResetCurrency() {
	m.currency = nil
	delete(m.clearedFields, securityposition.FieldCurrency)
}

// SetPrice sets the "price" field.
func (m *SecurityPositionMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SecurityPositionMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *SecurityPositionMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SecurityPositionMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *SecurityPositionMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[securityposition.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *SecurityPositionMutation) PriceCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *SecurityPositionMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, securityposition.FieldPrice)
}

// SetAmount sets the "amount" field.
func (m *SecurityPositionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *SecurityPositionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *SecurityPositionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *SecurityPositionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *SecurityPositionMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[securityposition.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *SecurityPositionMutation) AmountCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *SecurityPositionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, securityposition.FieldAmount)
}

// SetCostAmount sets the "cost_amount" field.
func (m *SecurityPositionMutation) SetCostAmount(f float64) {
	m.cost_amount = &f
	m.addcost_amount = nil
}

// CostAmount returns the value of the "cost_amount" field in the mutation.
func (m *SecurityPositionMutation) CostAmount() (r float64, exists bool) {
	v := m.cost_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCostAmount returns the old "cost_amount" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldCostAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCostAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCostAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCostAmount: %w", err)
	}
	return oldValue.CostAmount, nil
}

// AddCostAmount adds f to the "cost_amount" field.
func (m *SecurityPositionMutation) AddCostAmount(f float64) {
	if m.addcost_amount != nil {
		*m.addcost_amount += f
	} else {
		m.addcost_amount = &f
	}
}

// AddedCostAmount returns the value that was added to the "cost_amount" field in this mutation.
func (m *SecurityPositionMutation) AddedCostAmount() (r float64, exists bool) {
	v := m.addcost_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearCostAmount clears the value of the "cost_amount" field.
func (m *SecurityPositionMutation) ClearCostAmount() {
	m.cost_amount = nil
	m.addcost_amount = nil
	m.clearedFields[securityposition.FieldCostAmount] = struct{}{}
}

// CostAmountCleared returns if the "cost_amount" field was cleared in this mutation.
func (m *SecurityPositionMutation) CostAmountCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldCostAmount]
	return ok
}

// ResetCostAmount resets all changes to the "cost_amount" field.
func (m *SecurityPositionMutation) ResetCostAmount() {
	m.cost_amount = nil
	m.addcost_amount = nil
	delete(m.clearedFields, securityposition.FieldCostAmount)
}

// SetCost sets the "cost" field.
func (m *SecurityPositionMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *SecurityPositionMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldCost(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *SecurityPositionMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *SecurityPositionMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ClearCost clears the value of the "cost" field.
func (m *SecurityPositionMutation) ClearCost() {
	m.cost = nil
	m.addcost = nil
	m.clearedFields[securityposition.FieldCost] = struct{}{}
}

// CostCleared returns if the "cost" field was cleared in this mutation.
func (m *SecurityPositionMutation) CostCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldCost]
	return ok
}

// ResetCost resets all changes to the "cost" field.
func (m *SecurityPositionMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
	delete(m.clearedFields, securityposition.FieldCost)
}

// SetFxRate sets the "fx_rate" field.
func (m *SecurityPositionMutation) SetFxRate(f float64) {
	m.fx_rate = &f
	m.addfx_rate = nil
}

// FxRate returns the value of the "fx_rate" field in the mutation.
func (m *SecurityPositionMutation) FxRate() (r float64, exists bool) {
	v := m.fx_rate
	if v == nil {
		return
	}
	return *v, true
}

// OldFxRate returns the old "fx_rate" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldFxRate(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFxRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFxRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFxRate: %w", err)
	}
	return oldValue.FxRate, nil
}

// AddFxRate adds f to the "fx_rate" field.
func (m *SecurityPositionMutation) AddFxRate(f float64) {
	if m.addfx_rate != nil {
		*m.addfx_rate += f
	} else {
		m.addfx_rate = &f
	}
}

// AddedFxRate returns the value that was added to the "fx_rate" field in this mutation.
func (m *SecurityPositionMutation) AddedFxRate() (r float64, exists bool) {
	v := m.addfx_rate
	if v == nil {
		return
	}
	return *v, true
}

// ClearFxRate clears the value of the "fx_rate" field.
func (m *SecurityPositionMutation) ClearFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	m.clearedFields[securityposition.FieldFxRate] = struct{}{}
}

// FxRateCleared returns if the "fx_rate" field was cleared in this mutation.
func (m *SecurityPositionMutation) FxRateCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldFxRate]
	return ok
}

// ResetFxRate resets all changes to the "fx_rate" field.
func (m *SecurityPositionMutation) ResetFxRate() {
	m.fx_rate = nil
	m.addfx_rate = nil
	delete(m.clearedFields, securityposition.FieldFxRate)
}

// SetStlCurrency sets the "stl_currency" field.
func (m *SecurityPositionMutation) SetStlCurrency(s string) {
	m.stl_currency = &s
}

// StlCurrency returns the value of the "stl_currency" field in the mutation.
func (m *SecurityPositionMutation) StlCurrency() (r string, exists bool) {
	v := m.stl_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldStlCurrency returns the old "stl_currency" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlCurrency(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlCurrency: %w", err)
	}
	return oldValue.StlCurrency, nil
}

// ClearStlCurrency clears the value of the "stl_currency" field.
func (m *SecurityPositionMutation) ClearStlCurrency() {
	m.stl_currency = nil
	m.clearedFields[securityposition.FieldStlCurrency] = struct{}{}
}

// StlCurrencyCleared returns if the "stl_currency" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlCurrencyCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlCurrency]
	return ok
}

// ResetStlCurrency resets all changes to the "stl_currency" field.
func (m *SecurityPositionMutation) ResetStlCurrency() {
	m.stl_currency = nil
	delete(m.clearedFields, securityposition.FieldStlCurrency)
}

// SetStlAmount sets the "stl_amount" field.
func (m *SecurityPositionMutation) SetStlAmount(f float64) {
	m.stl_amount = &f
	m.addstl_amount = nil
}

// StlAmount returns the value of the "stl_amount" field in the mutation.
func (m *SecurityPositionMutation) StlAmount() (r float64, exists bool) {
	v := m.stl_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStlAmount returns the old "stl_amount" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlAmount: %w", err)
	}
	return oldValue.StlAmount, nil
}

// AddStlAmount adds f to the "stl_amount" field.
func (m *SecurityPositionMutation) AddStlAmount(f float64) {
	if m.addstl_amount != nil {
		*m.addstl_amount += f
	} else {
		m.addstl_amount = &f
	}
}

// AddedStlAmount returns the value that was added to the "stl_amount" field in this mutation.
func (m *SecurityPositionMutation) AddedStlAmount() (r float64, exists bool) {
	v := m.addstl_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlAmount clears the value of the "stl_amount" field.
func (m *SecurityPositionMutation) ClearStlAmount() {
	m.stl_amount = nil
	m.addstl_amount = nil
	m.clearedFields[securityposition.FieldStlAmount] = struct{}{}
}

// StlAmountCleared returns if the "stl_amount" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlAmountCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlAmount]
	return ok
}

// ResetStlAmount resets all changes to the "stl_amount" field.
func (m *SecurityPositionMutation) ResetStlAmount() {
	m.stl_amount = nil
	m.addstl_amount = nil
	delete(m.clearedFields, securityposition.FieldStlAmount)
}

// SetStlCost sets the "stl_cost" field.
func (m *SecurityPositionMutation) SetStlCost(f float64) {
	m.stl_cost = &f
	m.addstl_cost = nil
}

// StlCost returns the value of the "stl_cost" field in the mutation.
func (m *SecurityPositionMutation) StlCost() (r float64, exists bool) {
	v := m.stl_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldStlCost returns the old "stl_cost" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlCost(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlCost: %w", err)
	}
	return oldValue.StlCost, nil
}

// AddStlCost adds f to the "stl_cost" field.
func (m *SecurityPositionMutation) AddStlCost(f float64) {
	if m.addstl_cost != nil {
		*m.addstl_cost += f
	} else {
		m.addstl_cost = &f
	}
}

// AddedStlCost returns the value that was added to the "stl_cost" field in this mutation.
func (m *SecurityPositionMutation) AddedStlCost() (r float64, exists bool) {
	v := m.addstl_cost
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlCost clears the value of the "stl_cost" field.
func (m *SecurityPositionMutation) ClearStlCost() {
	m.stl_cost = nil
	m.addstl_cost = nil
	m.clearedFields[securityposition.FieldStlCost] = struct{}{}
}

// StlCostCleared returns if the "stl_cost" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlCostCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlCost]
	return ok
}

// ResetStlCost resets all changes to the "stl_cost" field.
func (m *SecurityPositionMutation) ResetStlCost() {
	m.stl_cost = nil
	m.addstl_cost = nil
	delete(m.clearedFields, securityposition.FieldStlCost)
}

// SetStlMargin sets the "stl_margin" field.
func (m *SecurityPositionMutation) SetStlMargin(f float64) {
	m.stl_margin = &f
	m.addstl_margin = nil
}

// StlMargin returns the value of the "stl_margin" field in the mutation.
func (m *SecurityPositionMutation) StlMargin() (r float64, exists bool) {
	v := m.stl_margin
	if v == nil {
		return
	}
	return *v, true
}

// OldStlMargin returns the old "stl_margin" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlMargin(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlMargin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlMargin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlMargin: %w", err)
	}
	return oldValue.StlMargin, nil
}

// AddStlMargin adds f to the "stl_margin" field.
func (m *SecurityPositionMutation) AddStlMargin(f float64) {
	if m.addstl_margin != nil {
		*m.addstl_margin += f
	} else {
		m.addstl_margin = &f
	}
}

// AddedStlMargin returns the value that was added to the "stl_margin" field in this mutation.
func (m *SecurityPositionMutation) AddedStlMargin() (r float64, exists bool) {
	v := m.addstl_margin
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlMargin clears the value of the "stl_margin" field.
func (m *SecurityPositionMutation) ClearStlMargin() {
	m.stl_margin = nil
	m.addstl_margin = nil
	m.clearedFields[securityposition.FieldStlMargin] = struct{}{}
}

// StlMarginCleared returns if the "stl_margin" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlMarginCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlMargin]
	return ok
}

// ResetStlMargin resets all changes to the "stl_margin" field.
func (m *SecurityPositionMutation) ResetStlMargin() {
	m.stl_margin = nil
	m.addstl_margin = nil
	delete(m.clearedFields, securityposition.FieldStlMargin)
}

// SetStlCostAmount sets the "stl_cost_amount" field.
func (m *SecurityPositionMutation) SetStlCostAmount(f float64) {
	m.stl_cost_amount = &f
	m.addstl_cost_amount = nil
}

// StlCostAmount returns the value of the "stl_cost_amount" field in the mutation.
func (m *SecurityPositionMutation) StlCostAmount() (r float64, exists bool) {
	v := m.stl_cost_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldStlCostAmount returns the old "stl_cost_amount" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlCostAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlCostAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlCostAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlCostAmount: %w", err)
	}
	return oldValue.StlCostAmount, nil
}

// AddStlCostAmount adds f to the "stl_cost_amount" field.
func (m *SecurityPositionMutation) AddStlCostAmount(f float64) {
	if m.addstl_cost_amount != nil {
		*m.addstl_cost_amount += f
	} else {
		m.addstl_cost_amount = &f
	}
}

// AddedStlCostAmount returns the value that was added to the "stl_cost_amount" field in this mutation.
func (m *SecurityPositionMutation) AddedStlCostAmount() (r float64, exists bool) {
	v := m.addstl_cost_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlCostAmount clears the value of the "stl_cost_amount" field.
func (m *SecurityPositionMutation) ClearStlCostAmount() {
	m.stl_cost_amount = nil
	m.addstl_cost_amount = nil
	m.clearedFields[securityposition.FieldStlCostAmount] = struct{}{}
}

// StlCostAmountCleared returns if the "stl_cost_amount" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlCostAmountCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlCostAmount]
	return ok
}

// ResetStlCostAmount resets all changes to the "stl_cost_amount" field.
func (m *SecurityPositionMutation) ResetStlCostAmount() {
	m.stl_cost_amount = nil
	m.addstl_cost_amount = nil
	delete(m.clearedFields, securityposition.FieldStlCostAmount)
}

// SetStlMarginLv sets the "stl_margin_lv" field.
func (m *SecurityPositionMutation) SetStlMarginLv(f float64) {
	m.stl_margin_lv = &f
	m.addstl_margin_lv = nil
}

// StlMarginLv returns the value of the "stl_margin_lv" field in the mutation.
func (m *SecurityPositionMutation) StlMarginLv() (r float64, exists bool) {
	v := m.stl_margin_lv
	if v == nil {
		return
	}
	return *v, true
}

// OldStlMarginLv returns the old "stl_margin_lv" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlMarginLv(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlMarginLv is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlMarginLv requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlMarginLv: %w", err)
	}
	return oldValue.StlMarginLv, nil
}

// AddStlMarginLv adds f to the "stl_margin_lv" field.
func (m *SecurityPositionMutation) AddStlMarginLv(f float64) {
	if m.addstl_margin_lv != nil {
		*m.addstl_margin_lv += f
	} else {
		m.addstl_margin_lv = &f
	}
}

// AddedStlMarginLv returns the value that was added to the "stl_margin_lv" field in this mutation.
func (m *SecurityPositionMutation) AddedStlMarginLv() (r float64, exists bool) {
	v := m.addstl_margin_lv
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlMarginLv clears the value of the "stl_margin_lv" field.
func (m *SecurityPositionMutation) ClearStlMarginLv() {
	m.stl_margin_lv = nil
	m.addstl_margin_lv = nil
	m.clearedFields[securityposition.FieldStlMarginLv] = struct{}{}
}

// StlMarginLvCleared returns if the "stl_margin_lv" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlMarginLvCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlMarginLv]
	return ok
}

// ResetStlMarginLv resets all changes to the "stl_margin_lv" field.
func (m *SecurityPositionMutation) ResetStlMarginLv() {
	m.stl_margin_lv = nil
	m.addstl_margin_lv = nil
	delete(m.clearedFields, securityposition.FieldStlMarginLv)
}

// SetStlValPrice sets the "stl_val_price" field.
func (m *SecurityPositionMutation) SetStlValPrice(f float64) {
	m.stl_val_price = &f
	m.addstl_val_price = nil
}

// StlValPrice returns the value of the "stl_val_price" field in the mutation.
func (m *SecurityPositionMutation) StlValPrice() (r float64, exists bool) {
	v := m.stl_val_price
	if v == nil {
		return
	}
	return *v, true
}

// OldStlValPrice returns the old "stl_val_price" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldStlValPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStlValPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStlValPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStlValPrice: %w", err)
	}
	return oldValue.StlValPrice, nil
}

// AddStlValPrice adds f to the "stl_val_price" field.
func (m *SecurityPositionMutation) AddStlValPrice(f float64) {
	if m.addstl_val_price != nil {
		*m.addstl_val_price += f
	} else {
		m.addstl_val_price = &f
	}
}

// AddedStlValPrice returns the value that was added to the "stl_val_price" field in this mutation.
func (m *SecurityPositionMutation) AddedStlValPrice() (r float64, exists bool) {
	v := m.addstl_val_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearStlValPrice clears the value of the "stl_val_price" field.
func (m *SecurityPositionMutation) ClearStlValPrice() {
	m.stl_val_price = nil
	m.addstl_val_price = nil
	m.clearedFields[securityposition.FieldStlValPrice] = struct{}{}
}

// StlValPriceCleared returns if the "stl_val_price" field was cleared in this mutation.
func (m *SecurityPositionMutation) StlValPriceCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldStlValPrice]
	return ok
}

// ResetStlValPrice resets all changes to the "stl_val_price" field.
func (m *SecurityPositionMutation) ResetStlValPrice() {
	m.stl_val_price = nil
	m.addstl_val_price = nil
	delete(m.clearedFields, securityposition.FieldStlValPrice)
}

// SetInvalidAt sets the "invalid_at" field.
func (m *SecurityPositionMutation) SetInvalidAt(t time.Time) {
	m.invalid_at = &t
}

// InvalidAt returns the value of the "invalid_at" field in the mutation.
func (m *SecurityPositionMutation) InvalidAt() (r time.Time, exists bool) {
	v := m.invalid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInvalidAt returns the old "invalid_at" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldInvalidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvalidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvalidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvalidAt: %w", err)
	}
	return oldValue.InvalidAt, nil
}

// ClearInvalidAt clears the value of the "invalid_at" field.
func (m *SecurityPositionMutation) ClearInvalidAt() {
	m.invalid_at = nil
	m.clearedFields[securityposition.FieldInvalidAt] = struct{}{}
}

// InvalidAtCleared returns if the "invalid_at" field was cleared in this mutation.
func (m *SecurityPositionMutation) InvalidAtCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldInvalidAt]
	return ok
}

// ResetInvalidAt resets all changes to the "invalid_at" field.
func (m *SecurityPositionMutation) ResetInvalidAt() {
	m.invalid_at = nil
	delete(m.clearedFields, securityposition.FieldInvalidAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *SecurityPositionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SecurityPositionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SecurityPositionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[securityposition.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SecurityPositionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SecurityPositionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, securityposition.FieldCreatedAt)
}

// SetUniqueTag sets the "unique_tag" field.
func (m *SecurityPositionMutation) SetUniqueTag(s string) {
	m.unique_tag = &s
}

// UniqueTag returns the value of the "unique_tag" field in the mutation.
func (m *SecurityPositionMutation) UniqueTag() (r string, exists bool) {
	v := m.unique_tag
	if v == nil {
		return
	}
	return *v, true
}

// OldUniqueTag returns the old "unique_tag" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldUniqueTag(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniqueTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniqueTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniqueTag: %w", err)
	}
	return oldValue.UniqueTag, nil
}

// ClearUniqueTag clears the value of the "unique_tag" field.
func (m *SecurityPositionMutation) ClearUniqueTag() {
	m.unique_tag = nil
	m.clearedFields[securityposition.FieldUniqueTag] = struct{}{}
}

// UniqueTagCleared returns if the "unique_tag" field was cleared in this mutation.
func (m *SecurityPositionMutation) UniqueTagCleared() bool {
	_, ok := m.clearedFields[securityposition.FieldUniqueTag]
	return ok
}

// ResetUniqueTag resets all changes to the "unique_tag" field.
func (m *SecurityPositionMutation) ResetUniqueTag() {
	m.unique_tag = nil
	delete(m.clearedFields, securityposition.FieldUniqueTag)
}

// SetOrgID sets the "org_id" field.
func (m *SecurityPositionMutation) SetOrgID(i int) {
	m.org_id = &i
	m.addorg_id = nil
}

// OrgID returns the value of the "org_id" field in the mutation.
func (m *SecurityPositionMutation) OrgID() (r int, exists bool) {
	v := m.org_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrgID returns the old "org_id" field's value of the SecurityPosition entity.
// If the SecurityPosition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SecurityPositionMutation) OldOrgID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrgID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrgID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrgID: %w", err)
	}
	return oldValue.OrgID, nil
}

// AddOrgID adds i to the "org_id" field.
func (m *SecurityPositionMutation) AddOrgID(i int) {
	if m.addorg_id != nil {
		*m.addorg_id += i
	} else {
		m.addorg_id = &i
	}
}

// AddedOrgID returns the value that was added to the "org_id" field in this mutation.
func (m *SecurityPositionMutation) AddedOrgID() (r int, exists bool) {
	v := m.addorg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrgID resets all changes to the "org_id" field.
func (m *SecurityPositionMutation) ResetOrgID() {
	m.org_id = nil
	m.addorg_id = nil
}

// Where appends a list predicates to the SecurityPositionMutation builder.
func (m *SecurityPositionMutation) Where(ps ...predicate.SecurityPosition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SecurityPositionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SecurityPosition).
func (m *SecurityPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SecurityPositionMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.parent_id != nil {
		fields = append(fields, securityposition.FieldParentID)
	}
	if m.account_id != nil {
		fields = append(fields, securityposition.FieldAccountID)
	}
	if m.security_account_id != nil {
		fields = append(fields, securityposition.FieldSecurityAccountID)
	}
	if m.position_type != nil {
		fields = append(fields, securityposition.FieldPositionType)
	}
	if m.cd_direction != nil {
		fields = append(fields, securityposition.FieldCdDirection)
	}
	if m.project_id != nil {
		fields = append(fields, securityposition.FieldProjectID)
	}
	if m.product_id != nil {
		fields = append(fields, securityposition.FieldProductID)
	}
	if m.material_id != nil {
		fields = append(fields, securityposition.FieldMaterialID)
	}
	if m.material_no != nil {
		fields = append(fields, securityposition.FieldMaterialNo)
	}
	if m.multiplier != nil {
		fields = append(fields, securityposition.FieldMultiplier)
	}
	if m.balance != nil {
		fields = append(fields, securityposition.FieldBalance)
	}
	if m.available != nil {
		fields = append(fields, securityposition.FieldAvailable)
	}
	if m.freeze != nil {
		fields = append(fields, securityposition.FieldFreeze)
	}
	if m.afloat != nil {
		fields = append(fields, securityposition.FieldAfloat)
	}
	if m.unit != nil {
		fields = append(fields, securityposition.FieldUnit)
	}
	if m.spec != nil {
		fields = append(fields, securityposition.FieldSpec)
	}
	if m.currency != nil {
		fields = append(fields, securityposition.FieldCurrency)
	}
	if m.price != nil {
		fields = append(fields, securityposition.FieldPrice)
	}
	if m.amount != nil {
		fields = append(fields, securityposition.FieldAmount)
	}
	if m.cost_amount != nil {
		fields = append(fields, securityposition.FieldCostAmount)
	}
	if m.cost != nil {
		fields = append(fields, securityposition.FieldCost)
	}
	if m.fx_rate != nil {
		fields = append(fields, securityposition.FieldFxRate)
	}
	if m.stl_currency != nil {
		fields = append(fields, securityposition.FieldStlCurrency)
	}
	if m.stl_amount != nil {
		fields = append(fields, securityposition.FieldStlAmount)
	}
	if m.stl_cost != nil {
		fields = append(fields, securityposition.FieldStlCost)
	}
	if m.stl_margin != nil {
		fields = append(fields, securityposition.FieldStlMargin)
	}
	if m.stl_cost_amount != nil {
		fields = append(fields, securityposition.FieldStlCostAmount)
	}
	if m.stl_margin_lv != nil {
		fields = append(fields, securityposition.FieldStlMarginLv)
	}
	if m.stl_val_price != nil {
		fields = append(fields, securityposition.FieldStlValPrice)
	}
	if m.invalid_at != nil {
		fields = append(fields, securityposition.FieldInvalidAt)
	}
	if m.created_at != nil {
		fields = append(fields, securityposition.FieldCreatedAt)
	}
	if m.unique_tag != nil {
		fields = append(fields, securityposition.FieldUniqueTag)
	}
	if m.org_id != nil {
		fields = append(fields, securityposition.FieldOrgID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SecurityPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case securityposition.FieldParentID:
		return m.ParentID()
	case securityposition.FieldAccountID:
		return m.AccountID()
	case securityposition.FieldSecurityAccountID:
		return m.SecurityAccountID()
	case securityposition.FieldPositionType:
		return m.PositionType()
	case securityposition.FieldCdDirection:
		return m.CdDirection()
	case securityposition.FieldProjectID:
		return m.ProjectID()
	case securityposition.FieldProductID:
		return m.ProductID()
	case securityposition.FieldMaterialID:
		return m.MaterialID()
	case securityposition.FieldMaterialNo:
		return m.MaterialNo()
	case securityposition.FieldMultiplier:
		return m.Multiplier()
	case securityposition.FieldBalance:
		return m.Balance()
	case securityposition.FieldAvailable:
		return m.Available()
	case securityposition.FieldFreeze:
		return m.Freeze()
	case securityposition.FieldAfloat:
		return m.Afloat()
	case securityposition.FieldUnit:
		return m.Unit()
	case securityposition.FieldSpec:
		return m.Spec()
	case securityposition.FieldCurrency:
		return m.Currency()
	case securityposition.FieldPrice:
		return m.Price()
	case securityposition.FieldAmount:
		return m.Amount()
	case securityposition.FieldCostAmount:
		return m.CostAmount()
	case securityposition.FieldCost:
		return m.Cost()
	case securityposition.FieldFxRate:
		return m.FxRate()
	case securityposition.FieldStlCurrency:
		return m.StlCurrency()
	case securityposition.FieldStlAmount:
		return m.StlAmount()
	case securityposition.FieldStlCost:
		return m.StlCost()
	case securityposition.FieldStlMargin:
		return m.StlMargin()
	case securityposition.FieldStlCostAmount:
		return m.StlCostAmount()
	case securityposition.FieldStlMarginLv:
		return m.StlMarginLv()
	case securityposition.FieldStlValPrice:
		return m.StlValPrice()
	case securityposition.FieldInvalidAt:
		return m.InvalidAt()
	case securityposition.FieldCreatedAt:
		return m.CreatedAt()
	case securityposition.FieldUniqueTag:
		return m.UniqueTag()
	case securityposition.FieldOrgID:
		return m.OrgID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SecurityPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case securityposition.FieldParentID:
		return m.OldParentID(ctx)
	case securityposition.FieldAccountID:
		return m.OldAccountID(ctx)
	case securityposition.FieldSecurityAccountID:
		return m.OldSecurityAccountID(ctx)
	case securityposition.FieldPositionType:
		return m.OldPositionType(ctx)
	case securityposition.FieldCdDirection:
		return m.OldCdDirection(ctx)
	case securityposition.FieldProjectID:
		return m.OldProjectID(ctx)
	case securityposition.FieldProductID:
		return m.OldProductID(ctx)
	case securityposition.FieldMaterialID:
		return m.OldMaterialID(ctx)
	case securityposition.FieldMaterialNo:
		return m.OldMaterialNo(ctx)
	case securityposition.FieldMultiplier:
		return m.OldMultiplier(ctx)
	case securityposition.FieldBalance:
		return m.OldBalance(ctx)
	case securityposition.FieldAvailable:
		return m.OldAvailable(ctx)
	case securityposition.FieldFreeze:
		return m.OldFreeze(ctx)
	case securityposition.FieldAfloat:
		return m.OldAfloat(ctx)
	case securityposition.FieldUnit:
		return m.OldUnit(ctx)
	case securityposition.FieldSpec:
		return m.OldSpec(ctx)
	case securityposition.FieldCurrency:
		return m.OldCurrency(ctx)
	case securityposition.FieldPrice:
		return m.OldPrice(ctx)
	case securityposition.FieldAmount:
		return m.OldAmount(ctx)
	case securityposition.FieldCostAmount:
		return m.OldCostAmount(ctx)
	case securityposition.FieldCost:
		return m.OldCost(ctx)
	case securityposition.FieldFxRate:
		return m.OldFxRate(ctx)
	case securityposition.FieldStlCurrency:
		return m.OldStlCurrency(ctx)
	case securityposition.FieldStlAmount:
		return m.OldStlAmount(ctx)
	case securityposition.FieldStlCost:
		return m.OldStlCost(ctx)
	case securityposition.FieldStlMargin:
		return m.OldStlMargin(ctx)
	case securityposition.FieldStlCostAmount:
		return m.OldStlCostAmount(ctx)
	case securityposition.FieldStlMarginLv:
		return m.OldStlMarginLv(ctx)
	case securityposition.FieldStlValPrice:
		return m.OldStlValPrice(ctx)
	case securityposition.FieldInvalidAt:
		return m.OldInvalidAt(ctx)
	case securityposition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case securityposition.FieldUniqueTag:
		return m.OldUniqueTag(ctx)
	case securityposition.FieldOrgID:
		return m.OldOrgID(ctx)
	}
	return nil, fmt.Errorf("unknown SecurityPosition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case securityposition.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case securityposition.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case securityposition.FieldSecurityAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecurityAccountID(v)
		return nil
	case securityposition.FieldPositionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionType(v)
		return nil
	case securityposition.FieldCdDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCdDirection(v)
		return nil
	case securityposition.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case securityposition.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case securityposition.FieldMaterialID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialID(v)
		return nil
	case securityposition.FieldMaterialNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialNo(v)
		return nil
	case securityposition.FieldMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiplier(v)
		return nil
	case securityposition.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case securityposition.FieldAvailable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailable(v)
		return nil
	case securityposition.FieldFreeze:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeze(v)
		return nil
	case securityposition.FieldAfloat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfloat(v)
		return nil
	case securityposition.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case securityposition.FieldSpec:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpec(v)
		return nil
	case securityposition.FieldCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrency(v)
		return nil
	case securityposition.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case securityposition.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case securityposition.FieldCostAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCostAmount(v)
		return nil
	case securityposition.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case securityposition.FieldFxRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFxRate(v)
		return nil
	case securityposition.FieldStlCurrency:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlCurrency(v)
		return nil
	case securityposition.FieldStlAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlAmount(v)
		return nil
	case securityposition.FieldStlCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlCost(v)
		return nil
	case securityposition.FieldStlMargin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlMargin(v)
		return nil
	case securityposition.FieldStlCostAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlCostAmount(v)
		return nil
	case securityposition.FieldStlMarginLv:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlMarginLv(v)
		return nil
	case securityposition.FieldStlValPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStlValPrice(v)
		return nil
	case securityposition.FieldInvalidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvalidAt(v)
		return nil
	case securityposition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case securityposition.FieldUniqueTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniqueTag(v)
		return nil
	case securityposition.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityPosition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SecurityPositionMutation) AddedFields() []string {
	var fields []string
	if m.addparent_id != nil {
		fields = append(fields, securityposition.FieldParentID)
	}
	if m.addaccount_id != nil {
		fields = append(fields, securityposition.FieldAccountID)
	}
	if m.addsecurity_account_id != nil {
		fields = append(fields, securityposition.FieldSecurityAccountID)
	}
	if m.addposition_type != nil {
		fields = append(fields, securityposition.FieldPositionType)
	}
	if m.addcd_direction != nil {
		fields = append(fields, securityposition.FieldCdDirection)
	}
	if m.addproject_id != nil {
		fields = append(fields, securityposition.FieldProjectID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, securityposition.FieldProductID)
	}
	if m.addmaterial_id != nil {
		fields = append(fields, securityposition.FieldMaterialID)
	}
	if m.addmultiplier != nil {
		fields = append(fields, securityposition.FieldMultiplier)
	}
	if m.addbalance != nil {
		fields = append(fields, securityposition.FieldBalance)
	}
	if m.addavailable != nil {
		fields = append(fields, securityposition.FieldAvailable)
	}
	if m.addfreeze != nil {
		fields = append(fields, securityposition.FieldFreeze)
	}
	if m.addafloat != nil {
		fields = append(fields, securityposition.FieldAfloat)
	}
	if m.addprice != nil {
		fields = append(fields, securityposition.FieldPrice)
	}
	if m.addamount != nil {
		fields = append(fields, securityposition.FieldAmount)
	}
	if m.addcost_amount != nil {
		fields = append(fields, securityposition.FieldCostAmount)
	}
	if m.addcost != nil {
		fields = append(fields, securityposition.FieldCost)
	}
	if m.addfx_rate != nil {
		fields = append(fields, securityposition.FieldFxRate)
	}
	if m.addstl_amount != nil {
		fields = append(fields, securityposition.FieldStlAmount)
	}
	if m.addstl_cost != nil {
		fields = append(fields, securityposition.FieldStlCost)
	}
	if m.addstl_margin != nil {
		fields = append(fields, securityposition.FieldStlMargin)
	}
	if m.addstl_cost_amount != nil {
		fields = append(fields, securityposition.FieldStlCostAmount)
	}
	if m.addstl_margin_lv != nil {
		fields = append(fields, securityposition.FieldStlMarginLv)
	}
	if m.addstl_val_price != nil {
		fields = append(fields, securityposition.FieldStlValPrice)
	}
	if m.addorg_id != nil {
		fields = append(fields, securityposition.FieldOrgID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SecurityPositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case securityposition.FieldParentID:
		return m.AddedParentID()
	case securityposition.FieldAccountID:
		return m.AddedAccountID()
	case securityposition.FieldSecurityAccountID:
		return m.AddedSecurityAccountID()
	case securityposition.FieldPositionType:
		return m.AddedPositionType()
	case securityposition.FieldCdDirection:
		return m.AddedCdDirection()
	case securityposition.FieldProjectID:
		return m.AddedProjectID()
	case securityposition.FieldProductID:
		return m.AddedProductID()
	case securityposition.FieldMaterialID:
		return m.AddedMaterialID()
	case securityposition.FieldMultiplier:
		return m.AddedMultiplier()
	case securityposition.FieldBalance:
		return m.AddedBalance()
	case securityposition.FieldAvailable:
		return m.AddedAvailable()
	case securityposition.FieldFreeze:
		return m.AddedFreeze()
	case securityposition.FieldAfloat:
		return m.AddedAfloat()
	case securityposition.FieldPrice:
		return m.AddedPrice()
	case securityposition.FieldAmount:
		return m.AddedAmount()
	case securityposition.FieldCostAmount:
		return m.AddedCostAmount()
	case securityposition.FieldCost:
		return m.AddedCost()
	case securityposition.FieldFxRate:
		return m.AddedFxRate()
	case securityposition.FieldStlAmount:
		return m.AddedStlAmount()
	case securityposition.FieldStlCost:
		return m.AddedStlCost()
	case securityposition.FieldStlMargin:
		return m.AddedStlMargin()
	case securityposition.FieldStlCostAmount:
		return m.AddedStlCostAmount()
	case securityposition.FieldStlMarginLv:
		return m.AddedStlMarginLv()
	case securityposition.FieldStlValPrice:
		return m.AddedStlValPrice()
	case securityposition.FieldOrgID:
		return m.AddedOrgID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SecurityPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case securityposition.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddParentID(v)
		return nil
	case securityposition.FieldAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	case securityposition.FieldSecurityAccountID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecurityAccountID(v)
		return nil
	case securityposition.FieldPositionType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPositionType(v)
		return nil
	case securityposition.FieldCdDirection:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCdDirection(v)
		return nil
	case securityposition.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProjectID(v)
		return nil
	case securityposition.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case securityposition.FieldMaterialID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaterialID(v)
		return nil
	case securityposition.FieldMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMultiplier(v)
		return nil
	case securityposition.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case securityposition.FieldAvailable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailable(v)
		return nil
	case securityposition.FieldFreeze:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeze(v)
		return nil
	case securityposition.FieldAfloat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfloat(v)
		return nil
	case securityposition.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case securityposition.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case securityposition.FieldCostAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCostAmount(v)
		return nil
	case securityposition.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case securityposition.FieldFxRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFxRate(v)
		return nil
	case securityposition.FieldStlAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlAmount(v)
		return nil
	case securityposition.FieldStlCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlCost(v)
		return nil
	case securityposition.FieldStlMargin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlMargin(v)
		return nil
	case securityposition.FieldStlCostAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlCostAmount(v)
		return nil
	case securityposition.FieldStlMarginLv:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlMarginLv(v)
		return nil
	case securityposition.FieldStlValPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStlValPrice(v)
		return nil
	case securityposition.FieldOrgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrgID(v)
		return nil
	}
	return fmt.Errorf("unknown SecurityPosition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SecurityPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(securityposition.FieldAccountID) {
		fields = append(fields, securityposition.FieldAccountID)
	}
	if m.FieldCleared(securityposition.FieldPositionType) {
		fields = append(fields, securityposition.FieldPositionType)
	}
	if m.FieldCleared(securityposition.FieldCdDirection) {
		fields = append(fields, securityposition.FieldCdDirection)
	}
	if m.FieldCleared(securityposition.FieldProjectID) {
		fields = append(fields, securityposition.FieldProjectID)
	}
	if m.FieldCleared(securityposition.FieldMaterialID) {
		fields = append(fields, securityposition.FieldMaterialID)
	}
	if m.FieldCleared(securityposition.FieldMaterialNo) {
		fields = append(fields, securityposition.FieldMaterialNo)
	}
	if m.FieldCleared(securityposition.FieldMultiplier) {
		fields = append(fields, securityposition.FieldMultiplier)
	}
	if m.FieldCleared(securityposition.FieldBalance) {
		fields = append(fields, securityposition.FieldBalance)
	}
	if m.FieldCleared(securityposition.FieldAvailable) {
		fields = append(fields, securityposition.FieldAvailable)
	}
	if m.FieldCleared(securityposition.FieldFreeze) {
		fields = append(fields, securityposition.FieldFreeze)
	}
	if m.FieldCleared(securityposition.FieldAfloat) {
		fields = append(fields, securityposition.FieldAfloat)
	}
	if m.FieldCleared(securityposition.FieldUnit) {
		fields = append(fields, securityposition.FieldUnit)
	}
	if m.FieldCleared(securityposition.FieldSpec) {
		fields = append(fields, securityposition.FieldSpec)
	}
	if m.FieldCleared(securityposition.FieldCurrency) {
		fields = append(fields, securityposition.FieldCurrency)
	}
	if m.FieldCleared(securityposition.FieldPrice) {
		fields = append(fields, securityposition.FieldPrice)
	}
	if m.FieldCleared(securityposition.FieldAmount) {
		fields = append(fields, securityposition.FieldAmount)
	}
	if m.FieldCleared(securityposition.FieldCostAmount) {
		fields = append(fields, securityposition.FieldCostAmount)
	}
	if m.FieldCleared(securityposition.FieldCost) {
		fields = append(fields, securityposition.FieldCost)
	}
	if m.FieldCleared(securityposition.FieldFxRate) {
		fields = append(fields, securityposition.FieldFxRate)
	}
	if m.FieldCleared(securityposition.FieldStlCurrency) {
		fields = append(fields, securityposition.FieldStlCurrency)
	}
	if m.FieldCleared(securityposition.FieldStlAmount) {
		fields = append(fields, securityposition.FieldStlAmount)
	}
	if m.FieldCleared(securityposition.FieldStlCost) {
		fields = append(fields, securityposition.FieldStlCost)
	}
	if m.FieldCleared(securityposition.FieldStlMargin) {
		fields = append(fields, securityposition.FieldStlMargin)
	}
	if m.FieldCleared(securityposition.FieldStlCostAmount) {
		fields = append(fields, securityposition.FieldStlCostAmount)
	}
	if m.FieldCleared(securityposition.FieldStlMarginLv) {
		fields = append(fields, securityposition.FieldStlMarginLv)
	}
	if m.FieldCleared(securityposition.FieldStlValPrice) {
		fields = append(fields, securityposition.FieldStlValPrice)
	}
	if m.FieldCleared(securityposition.FieldInvalidAt) {
		fields = append(fields, securityposition.FieldInvalidAt)
	}
	if m.FieldCleared(securityposition.FieldCreatedAt) {
		fields = append(fields, securityposition.FieldCreatedAt)
	}
	if m.FieldCleared(securityposition.FieldUniqueTag) {
		fields = append(fields, securityposition.FieldUniqueTag)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SecurityPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SecurityPositionMutation) ClearField(name string) error {
	switch name {
	case securityposition.FieldAccountID:
		m.ClearAccountID()
		return nil
	case securityposition.FieldPositionType:
		m.ClearPositionType()
		return nil
	case securityposition.FieldCdDirection:
		m.ClearCdDirection()
		return nil
	case securityposition.FieldProjectID:
		m.ClearProjectID()
		return nil
	case securityposition.FieldMaterialID:
		m.ClearMaterialID()
		return nil
	case securityposition.FieldMaterialNo:
		m.ClearMaterialNo()
		return nil
	case securityposition.FieldMultiplier:
		m.ClearMultiplier()
		return nil
	case securityposition.FieldBalance:
		m.ClearBalance()
		return nil
	case securityposition.FieldAvailable:
		m.ClearAvailable()
		return nil
	case securityposition.FieldFreeze:
		m.ClearFreeze()
		return nil
	case securityposition.FieldAfloat:
		m.ClearAfloat()
		return nil
	case securityposition.FieldUnit:
		m.ClearUnit()
		return nil
	case securityposition.FieldSpec:
		m.ClearSpec()
		return nil
	case securityposition.FieldCurrency:
		m.ClearCurrency()
		return nil
	case securityposition.FieldPrice:
		m.ClearPrice()
		return nil
	case securityposition.FieldAmount:
		m.ClearAmount()
		return nil
	case securityposition.FieldCostAmount:
		m.ClearCostAmount()
		return nil
	case securityposition.FieldCost:
		m.ClearCost()
		return nil
	case securityposition.FieldFxRate:
		m.ClearFxRate()
		return nil
	case securityposition.FieldStlCurrency:
		m.ClearStlCurrency()
		return nil
	case securityposition.FieldStlAmount:
		m.ClearStlAmount()
		return nil
	case securityposition.FieldStlCost:
		m.ClearStlCost()
		return nil
	case securityposition.FieldStlMargin:
		m.ClearStlMargin()
		return nil
	case securityposition.FieldStlCostAmount:
		m.ClearStlCostAmount()
		return nil
	case securityposition.FieldStlMarginLv:
		m.ClearStlMarginLv()
		return nil
	case securityposition.FieldStlValPrice:
		m.ClearStlValPrice()
		return nil
	case securityposition.FieldInvalidAt:
		m.ClearInvalidAt()
		return nil
	case securityposition.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case securityposition.FieldUniqueTag:
		m.ClearUniqueTag()
		return nil
	}
	return fmt.Errorf("unknown SecurityPosition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SecurityPositionMutation) ResetField(name string) error {
	switch name {
	case securityposition.FieldParentID:
		m.ResetParentID()
		return nil
	case securityposition.FieldAccountID:
		m.ResetAccountID()
		return nil
	case securityposition.FieldSecurityAccountID:
		m.ResetSecurityAccountID()
		return nil
	case securityposition.FieldPositionType:
		m.ResetPositionType()
		return nil
	case securityposition.FieldCdDirection:
		m.ResetCdDirection()
		return nil
	case securityposition.FieldProjectID:
		m.ResetProjectID()
		return nil
	case securityposition.FieldProductID:
		m.ResetProductID()
		return nil
	case securityposition.FieldMaterialID:
		m.ResetMaterialID()
		return nil
	case securityposition.FieldMaterialNo:
		m.ResetMaterialNo()
		return nil
	case securityposition.FieldMultiplier:
		m.ResetMultiplier()
		return nil
	case securityposition.FieldBalance:
		m.ResetBalance()
		return nil
	case securityposition.FieldAvailable:
		m.ResetAvailable()
		return nil
	case securityposition.FieldFreeze:
		m.ResetFreeze()
		return nil
	case securityposition.FieldAfloat:
		m.ResetAfloat()
		return nil
	case securityposition.FieldUnit:
		m.ResetUnit()
		return nil
	case securityposition.FieldSpec:
		m.ResetSpec()
		return nil
	case securityposition.FieldCurrency:
		m.ResetCurrency()
		return nil
	case securityposition.FieldPrice:
		m.ResetPrice()
		return nil
	case securityposition.FieldAmount:
		m.ResetAmount()
		return nil
	case securityposition.FieldCostAmount:
		m.ResetCostAmount()
		return nil
	case securityposition.FieldCost:
		m.ResetCost()
		return nil
	case securityposition.FieldFxRate:
		m.ResetFxRate()
		return nil
	case securityposition.FieldStlCurrency:
		m.ResetStlCurrency()
		return nil
	case securityposition.FieldStlAmount:
		m.ResetStlAmount()
		return nil
	case securityposition.FieldStlCost:
		m.ResetStlCost()
		return nil
	case securityposition.FieldStlMargin:
		m.ResetStlMargin()
		return nil
	case securityposition.FieldStlCostAmount:
		m.ResetStlCostAmount()
		return nil
	case securityposition.FieldStlMarginLv:
		m.ResetStlMarginLv()
		return nil
	case securityposition.FieldStlValPrice:
		m.ResetStlValPrice()
		return nil
	case securityposition.FieldInvalidAt:
		m.ResetInvalidAt()
		return nil
	case securityposition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case securityposition.FieldUniqueTag:
		m.ResetUniqueTag()
		return nil
	case securityposition.FieldOrgID:
		m.ResetOrgID()
		return nil
	}
	return fmt.Errorf("unknown SecurityPosition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SecurityPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SecurityPositionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SecurityPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SecurityPositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SecurityPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SecurityPositionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SecurityPositionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SecurityPosition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SecurityPositionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SecurityPosition edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	age           *int
	addage        *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAge sets the "age" field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.Age()
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
